{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-truncate-markup.min.js","webpack:///webpack/bootstrap 9a3c38d6124b58be8e30","webpack:///./src/index.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}","webpack:///./node_modules/line-height/lib/line-height.js","webpack:///./node_modules/computed-style/dist/computedStyle.commonjs.js","webpack:///./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js","webpack:///(webpack)/buildin/global.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","writable","setPrototypeOf","__proto__","TruncateMarkup","_class","_temp2","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","__WEBPACK_IMPORTED_MODULE_1_line_height__","__WEBPACK_IMPORTED_MODULE_1_line_height___default","__WEBPACK_IMPORTED_MODULE_2_resize_observer_polyfill__","_typeof","Symbol","iterator","obj","_extends","assign","target","arguments","length","source","key","SPLIT","LEFT","RIGHT","toString","node","string","undefined","Array","isArray","newString","forEach","child","props","children","cloneWithChildren","isRootEl","level","style","display","validateTree","type","reduce","isValid","_React$Component","_temp","_this","_ret","_len","args","_key","apply","concat","state","text","childrenElementWithRef","lineHeight","splitDirectionSeq","shouldTruncate","wasLastCharTested","endFound","latestThatFits","origText","clientWidth","onAfterTruncateCalled","onAfterTruncate","wasTruncated","handleResize","initialRender","resizeObserver","setState","truncate","observe","el","componentDidMount","componentWillReceiveProps","nextProps","_this2","disconnect","componentDidUpdate","truncateOriginalText","fits","splice","push","tryToFit","componentWillUnmount","_this3","a","Children","only","cloneElement","ref","rootEl","splitDirections","newRootEl","split","ellipsis","newChildren","newChildrenWithEllipsis","shouldRenderEllipsis","wordWrap","isRoot","splitString","splitArray","splitDirection","restSplitDirections","slice","pivotIndex","Math","ceil","subString","substring","beforeString","afterString","array","item","subArray","beforeArray","afterArray","maxLines","lines","_el$getBoundingClient","getBoundingClientRect","height","computedLines","round","parseFloat","render","Component","defaultProps","lnHeightStr","computedStyle","lnHeight","_lnHeightStyle","indexOf","nodeName","_node","document","createElement","innerHTML","toUpperCase","setAttribute","fontSizeStr","fontSize","padding","border","body","appendChild","offsetHeight","removeChild","prop","getComputedStyle","window","currentStyle","replace","word","letter","global","toFloat","getBordersSize","styles","positions","len","size","position","getPaddings","paddings","list","getSVGContentRect","bbox","getBBox","createRectInit","width","getHTMLElementContentRect","clientHeight","emptyRect","getWindowOf","horizPad","left","right","vertPad","top","bottom","boxSizing","isDocumentElement","vertScrollbar","horizScrollbar","abs","documentElement","getContentRect","isBrowser","isSVGGraphicsElement","createReadOnlyRect","x","y","Constr","DOMRectReadOnly","rect","defineConfigurable","MapShim","getIndex","arr","result","some","entry","index","Map","anonymous","__entries__","prototypeAccessors","set","delete","entries","has","clear","callback","ctx","this$1","defineProperties","global$1","Function","requestAnimationFrame$1","requestAnimationFrame","bind","setTimeout","Date","now","trailingTimeout","throttle","delay","resolvePending","leadingCall","trailingCall","proxy","timeoutCallback","timeStamp","lastCallTime","transitionKeys","mutationObserverSupported","MutationObserver","ResizeObserverController","connected_","mutationEventsAdded_","mutationsObserver_","observers_","onTransitionEnd_","refresh","addObserver","observer","connect_","removeObserver","observers","disconnect_","updateObservers_","activeObservers","filter","gatherActive","hasActive","broadcastActive","addEventListener","attributes","childList","characterData","subtree","removeEventListener","propertyName","getInstance","instance_","keys","ownerDocument","defaultView","SVGGraphicsElement","SVGElement","ResizeObservation","broadcastWidth","broadcastHeight","contentRect_","isActive","broadcastRect","ResizeObserverEntry","rectInit","contentRect","ResizeObserverSPI","controller","callbackCtx","activeObservations_","observations_","callback_","controller_","callbackCtx_","Element","observations","unobserve","clearActive","observation","map","WeakMap","ResizeObserver","method","g","eval","e"],"mappings":"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","file":"react-truncate-markup.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactTruncateMarkup\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactTruncateMarkup\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactTruncateMarkup\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactTruncateMarkup\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TruncateMarkup; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_line_height__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_line_height___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_line_height__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_resize_observer_polyfill__ = __webpack_require__(5);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _class, _temp2;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar SPLIT = {\n  LEFT: true,\n  RIGHT: false\n};\n\nvar toString = function toString(node) {\n  var string = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  if (!node) {\n    return string;\n  } else if (typeof node === 'string') {\n    return string + node;\n  } else if (Array.isArray(node)) {\n    var newString = string;\n    node.forEach(function (child) {\n      newString = toString(child, newString);\n    });\n\n    return newString;\n  }\n\n  return toString(node.props.children, string);\n};\n\nvar cloneWithChildren = function cloneWithChildren(node, children, isRootEl, level) {\n  return _extends({}, node, {\n    props: _extends({}, node.props, {\n      style: _extends({}, node.props.style, isRootEl ? {\n        // root element cannot be an inline element because of the line calculation\n        display: (node.props.style || {}).display || 'block'\n      } : level === 2 ? {\n        // level 2 elements (direct children of the root element) need to be inline because of the ellipsis.\n        // if level 2 element was a block element, ellipsis would get rendered on a new line, breaking the max number of lines\n        display: (node.props.style || {}).display || 'inline-block'\n      } : {}),\n      children: children\n    })\n  });\n};\n\nvar validateTree = function validateTree(node) {\n  if (typeof node === 'string') {\n    return true;\n  } else if (typeof node.type === 'function') {\n    if (false) {\n      /* eslint-disable no-console */\n      console.error('ReactTruncateMarkup tried to render <' + node.type.name + ' />, but truncating React components is not supported, the full content is rendered instead. Only DOM elements are supported.');\n      /* eslint-enable */\n    }\n\n    return false;\n  }\n\n  if (node.props.children) {\n    if (Array.isArray(node.props.children)) {\n      return node.props.children.reduce(function (isValid, child) {\n        return isValid && validateTree(child);\n      }, true);\n    }\n\n    return validateTree(node.props.children);\n  }\n\n  return true;\n};\n\nvar TruncateMarkup = (_temp2 = _class = function (_React$Component) {\n  _inherits(TruncateMarkup, _React$Component);\n\n  function TruncateMarkup() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, TruncateMarkup);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n      text: _this.childrenElementWithRef(_this.props.children)\n    }, _this.isValid = validateTree(_this.props.children), _this.lineHeight = null, _this.splitDirectionSeq = [], _this.shouldTruncate = true, _this.wasLastCharTested = false, _this.endFound = false, _this.latestThatFits = null, _this.origText = null, _this.clientWidth = null, _this.onAfterTruncateCalled = false, _this.onAfterTruncate = function (wasTruncated) {\n      if (!_this.onAfterTruncateCalled) {\n        _this.onAfterTruncateCalled = true;\n        _this.props.onAfterTruncate(wasTruncated);\n      }\n    }, _this.handleResize = function () {\n      /* Wrapper element resize handing */\n      var initialRender = true;\n\n      _this.resizeObserver = new __WEBPACK_IMPORTED_MODULE_2_resize_observer_polyfill__[\"a\" /* default */](function () {\n        if (initialRender) {\n          // ResizeObserer cb is called on initial render too so we are skipping here\n          initialRender = false;\n        } else {\n          // wrapper element has been resized, recalculating with the original text\n          _this.shouldTruncate = false;\n          _this.latestThatFits = null;\n\n          _this.setState({\n            text: _this.origText\n          }, function () {\n            _this.shouldTruncate = true;\n            _this.onAfterTruncateCalled = false;\n            _this.truncate();\n          });\n        }\n      });\n\n      _this.resizeObserver.observe(_this.el);\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  TruncateMarkup.prototype.componentDidMount = function componentDidMount() {\n    if (!this.isValid) {\n      return;\n    }\n\n    this.origText = this.state.text;\n\n    // get the computed line-height of the parent element\n    // it'll be used for determining whether the text fits the container or not\n    this.lineHeight = this.props.lineHeight || __WEBPACK_IMPORTED_MODULE_1_line_height___default()(this.el);\n\n    this.truncate();\n\n    this.handleResize();\n  };\n\n  TruncateMarkup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _this2 = this;\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    this.shouldTruncate = false;\n    this.latestThatFits = null;\n    this.isValid = validateTree(nextProps.children);\n\n    this.setState({\n      text: this.childrenElementWithRef(nextProps.children)\n    }, function () {\n      if (!_this2.isValid) {\n        return;\n      }\n\n      _this2.origText = _this2.state.text;\n      _this2.lineHeight = nextProps.lineHeight || __WEBPACK_IMPORTED_MODULE_1_line_height___default()(_this2.el);\n      _this2.shouldTruncate = true;\n      _this2.truncate();\n\n      _this2.handleResize();\n    });\n  };\n\n  TruncateMarkup.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this.shouldTruncate === false || this.isValid === false) {\n      return;\n    }\n\n    if (this.endFound) {\n      // we've found the end where we cannot split the text further\n      // that means we've already found the max subtree that fits the container\n      // so we are rendering that\n      if (this.state.text !== this.latestThatFits) {\n        /* eslint-disable react/no-did-update-set-state */\n        this.setState({\n          text: this.latestThatFits\n        });\n\n        return;\n        /* eslint-enable */\n      } else if (this.el && this.el.clientWidth !== this.clientWidth) {\n        // edge case - scrollbar (dis?)appearing might mess up the container width\n        // causing strings that would normally fit on X lines to suddenly take up X+1 lines\n        // ugly fix - recalculate again\n        this.truncateOriginalText();\n\n        return;\n      }\n\n      this.onAfterTruncate( /* wasTruncated */true);\n\n      return;\n    }\n\n    if (this.splitDirectionSeq.length) {\n      if (this.fits()) {\n        this.latestThatFits = this.state.text;\n        this.clientWidth = this.el.clientWidth;\n        // we've found a subtree that fits the container\n        // but we need to check if we didn't cut too much of it off\n        // so we are changing the last splitting decision from splitting and going left\n        // to splitting and going right\n        this.splitDirectionSeq.splice(this.splitDirectionSeq.length - 1, 1, SPLIT.RIGHT, SPLIT.LEFT);\n      } else {\n        this.splitDirectionSeq.push(SPLIT.LEFT);\n      }\n\n      this.tryToFit(this.origText, this.splitDirectionSeq);\n    }\n  };\n\n  TruncateMarkup.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    this.lineHeight = null;\n    this.origText = null;\n    this.latestThatFits = null;\n    this.splitDirectionSeq = [];\n  };\n\n  TruncateMarkup.prototype.truncate = function truncate() {\n    if (this.fits()) {\n      // the whole text fits on the first try, no need to do anything else\n      this.shouldTruncate = false;\n      this.onAfterTruncate( /* wasTruncated */false);\n\n      return;\n    }\n\n    this.truncateOriginalText();\n  };\n\n  TruncateMarkup.prototype.childrenElementWithRef = function childrenElementWithRef(children) {\n    var _this3 = this;\n\n    var child = __WEBPACK_IMPORTED_MODULE_0_react___default.a.Children.only(children);\n\n    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(child, { ref: function ref(el) {\n        return _this3.el = el;\n      } });\n  };\n\n  TruncateMarkup.prototype.truncateOriginalText = function truncateOriginalText() {\n    this.endFound = false;\n    this.splitDirectionSeq = [SPLIT.LEFT];\n    this.wasLastCharTested = false;\n\n    this.tryToFit(this.origText, this.splitDirectionSeq);\n  };\n\n  /**\n   * Splits rootEl based on instructions and updates React's state with the returned element\n   * After React rerenders the new text, we'll check if the new text fits in componentDidUpdate\n   * @param  {ReactElement} rootEl - the original children element\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   */\n\n\n  TruncateMarkup.prototype.tryToFit = function tryToFit(rootEl, splitDirections) {\n    if (!rootEl.props.children) {\n      // no markup in container\n      return;\n    }\n\n    var newRootEl = this.split(rootEl, splitDirections, /* isRootEl */true);\n\n    var ellipsis = typeof this.props.ellipsis === 'function' ? this.props.ellipsis(newRootEl) : this.props.ellipsis;\n\n    ellipsis = (typeof ellipsis === 'undefined' ? 'undefined' : _typeof(ellipsis)) === 'object' ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(ellipsis, { key: 'ellipsis' }) : ellipsis;\n\n    var newChildren = newRootEl.props.children;\n    var newChildrenWithEllipsis = Array.isArray(newChildren) ? [].concat(newChildren, [ellipsis]) : [newChildren, ellipsis];\n\n    // edge case tradeoff EC#1 - on initial render it doesn't fit in the requested number of lines (1) so it starts truncating\n    // - because of truncating and the ellipsis position, div#lvl2 will have display set to 'inline-block',\n    //   causing the whole body to fit in 1 line again\n    // - if that happens, ellipsis is not needed anymore as the whole body is rendered\n    // - NOTE this could be fixed by checking for this exact case and handling it separately so it renders <div>foo {ellipsis}</div>\n    //\n    // Example:\n    // <TruncateMarkup lines={1}>\n    //   <div>\n    //     foo\n    //     <div id=\"lvl2\">bar</div>\n    //   </div>\n    // </TruncateMarkup>\n    var shouldRenderEllipsis = toString(newChildren) !== toString(this.origText);\n\n    this.setState({\n      text: _extends({}, newRootEl, {\n        props: _extends({}, newRootEl.props, {\n          style: _extends({\n            wordWrap: 'break-word'\n          }, newRootEl.props.style),\n          children: shouldRenderEllipsis ? newChildrenWithEllipsis : newChildren\n        })\n      })\n    });\n  };\n\n  /**\n   * Splits JSX node based on its type\n   * @param  {null|string|Array|Object} node - JSX node\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   * @return {null|string|Array|Object} - split JSX node\n   */\n\n\n  TruncateMarkup.prototype.split = function split(node, splitDirections) {\n    var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    if (!node) {\n      return node;\n    } else if (typeof node === 'string') {\n      return this.splitString(node, splitDirections);\n    } else if (Array.isArray(node)) {\n      return this.splitArray(node, splitDirections, level);\n    }\n\n    var newChildren = this.split(node.props.children, splitDirections,\n    /* isRoot */false, level + 1);\n\n    return cloneWithChildren(node, newChildren, isRoot, level);\n  };\n\n  TruncateMarkup.prototype.splitString = function splitString(string) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (!splitDirections.length) {\n      return string;\n    }\n\n    if (splitDirections.length && string.length === 1) {\n      // allow for an extra render test with the current character included\n      // in most cases this variation was already tested, but some edge cases require this check\n      // NOTE could be removed once EC#1 is taken care of\n      if (!this.wasLastCharTested) {\n        this.wasLastCharTested = true;\n      } else {\n        // we are trying to split further but we have nowhere to go now\n        // that means we've already found the max subtree that fits the container\n        this.endFound = true;\n      }\n\n      return string;\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n\n    var pivotIndex = Math.ceil(string.length / 2);\n\n    if (splitDirection === SPLIT.LEFT) {\n      var subString = string.substring(0, pivotIndex);\n\n      return this.splitString(subString, restSplitDirections);\n    }\n    var beforeString = string.substring(0, pivotIndex);\n    var afterString = string.substring(pivotIndex);\n\n    return beforeString + this.splitString(afterString, restSplitDirections);\n  };\n\n  TruncateMarkup.prototype.splitArray = function splitArray(array) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var level = arguments[2];\n\n    if (!splitDirections.length) {\n      return array;\n    }\n\n    if (array.length === 1) {\n      var item = array[0];\n\n\n      if (typeof item === 'string') {\n        return [this.splitString(item, splitDirections)];\n      }\n      var children = item.props.children;\n\n\n      var newChildren = this.split(children, splitDirections,\n      /* isRoot */false, level + 1);\n\n      return [cloneWithChildren(item, newChildren, /* isRoot */false, level)];\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n\n    var pivotIndex = Math.ceil(array.length / 2);\n\n    if (splitDirection === SPLIT.LEFT) {\n      var subArray = array.slice(0, pivotIndex);\n\n      return this.splitArray(subArray, restSplitDirections, level);\n    }\n    var beforeArray = array.slice(0, pivotIndex);\n    var afterArray = array.slice(pivotIndex);\n\n    return beforeArray.concat(this.splitArray(afterArray, restSplitDirections, level));\n  };\n\n  TruncateMarkup.prototype.fits = function fits() {\n    var maxLines = this.props.lines;\n\n    var _el$getBoundingClient = this.el.getBoundingClientRect(),\n        height = _el$getBoundingClient.height;\n\n    var computedLines = Math.round(height / parseFloat(this.lineHeight));\n\n    if (false) {\n      /* eslint-disable no-console */\n      console.warn('ReactTruncateMarkup: number of currently rendered lines: ' + computedLines + ', not truncating...\\n  It may be caused by target element not being visible at the time of computation.');\n      /* eslint-enable */\n    }\n\n    return maxLines >= computedLines;\n  };\n\n  TruncateMarkup.prototype.render = function render() {\n    return this.state.text;\n  };\n\n  return TruncateMarkup;\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component), _class.defaultProps = {\n  lines: 1,\n  ellipsis: '...',\n  lineHeight: '',\n  onAfterTruncate: function onAfterTruncate() {}\n}, _temp2);\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Load in dependencies\nvar computedStyle = __webpack_require__(4);\n\n/**\n * Calculate the `line-height` of a given node\n * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.\n * @returns {Number} `line-height` of the element in pixels\n */\nfunction lineHeight(node) {\n  // Grab the line-height via style\n  var lnHeightStr = computedStyle(node, 'line-height');\n  var lnHeight = parseFloat(lnHeightStr, 10);\n\n  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')\n  if (lnHeightStr === lnHeight + '') {\n    // Save the old lineHeight style and update the em unit to the element\n    var _lnHeightStyle = node.style.lineHeight;\n    node.style.lineHeight = lnHeightStr + 'em';\n\n    // Calculate the em based height\n    lnHeightStr = computedStyle(node, 'line-height');\n    lnHeight = parseFloat(lnHeightStr, 10);\n\n    // Revert the lineHeight style\n    if (_lnHeightStyle) {\n      node.style.lineHeight = _lnHeightStyle;\n    } else {\n      delete node.style.lineHeight;\n    }\n  }\n\n  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)\n  // DEV: `em` units are converted to `pt` in IE6\n  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length\n  if (lnHeightStr.indexOf('pt') !== -1) {\n    lnHeight *= 4;\n    lnHeight /= 3;\n  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)\n  } else if (lnHeightStr.indexOf('mm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 25.4;\n  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)\n  } else if (lnHeightStr.indexOf('cm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 2.54;\n  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)\n  } else if (lnHeightStr.indexOf('in') !== -1) {\n    lnHeight *= 96;\n  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)\n  } else if (lnHeightStr.indexOf('pc') !== -1) {\n    lnHeight *= 16;\n  }\n\n  // Continue our computation\n  lnHeight = Math.round(lnHeight);\n\n  // If the line-height is \"normal\", calculate by font-size\n  if (lnHeightStr === 'normal') {\n    // Create a temporary node\n    var nodeName = node.nodeName;\n    var _node = document.createElement(nodeName);\n    _node.innerHTML = '&nbsp;';\n\n    // If we have a text area, reset it to only 1 row\n    // https://github.com/twolfson/line-height/issues/4\n    if (nodeName.toUpperCase() === 'TEXTAREA') {\n      _node.setAttribute('rows', '1');\n    }\n\n    // Set the font-size of the element\n    var fontSizeStr = computedStyle(node, 'font-size');\n    _node.style.fontSize = fontSizeStr;\n\n    // Remove default padding/border which can affect offset height\n    // https://github.com/twolfson/line-height/issues/4\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    _node.style.padding = '0px';\n    _node.style.border = '0px';\n\n    // Append it to the body\n    var body = document.body;\n    body.appendChild(_node);\n\n    // Assume the line height of the element is the height\n    var height = _node.offsetHeight;\n    lnHeight = height;\n\n    // Remove our child from the DOM\n    body.removeChild(_node);\n  }\n\n  // Return the calculated height\n  return lnHeight;\n}\n\n// Export lineHeight\nmodule.exports = lineHeight;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n// This code has been refactored for 140 bytes\n// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js\nvar computedStyle = function (el, prop, getComputedStyle) {\n  getComputedStyle = window.getComputedStyle;\n\n  // In one fell swoop\n  return (\n    // If we have getComputedStyle\n    getComputedStyle ?\n      // Query it\n      // TODO: From CSS-Query notes, we might need (node, null) for FF\n      getComputedStyle(el) :\n\n    // Otherwise, we are in IE and use currentStyle\n      el.currentStyle\n  )[\n    // Switch to camelCase for CSSOM\n    // DEV: Grabbed from jQuery\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597\n    prop.replace(/-(\\w)/gi, function (word, letter) {\n      return letter.toUpperCase();\n    })\n  ];\n};\n\nmodule.exports = computedStyle;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\n/* eslint-disable require-jsdoc, valid-jsdoc */\nvar MapShim = (function () {\n    if (typeof Map !== 'undefined') {\n        return Map;\n    }\n\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\n    function getIndex(arr, key) {\n        var result = -1;\n\n        arr.some(function (entry, index) {\n            if (entry[0] === key) {\n                result = index;\n\n                return true;\n            }\n\n            return false;\n        });\n\n        return result;\n    }\n\n    return (function () {\n        function anonymous() {\n            this.__entries__ = [];\n        }\n\n        var prototypeAccessors = { size: { configurable: true } };\n\n        /**\r\n         * @returns {boolean}\r\n         */\n        prototypeAccessors.size.get = function () {\n            return this.__entries__.length;\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\n        anonymous.prototype.get = function (key) {\n            var index = getIndex(this.__entries__, key);\n            var entry = this.__entries__[index];\n\n            return entry && entry[1];\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.set = function (key, value) {\n            var index = getIndex(this.__entries__, key);\n\n            if (~index) {\n                this.__entries__[index][1] = value;\n            } else {\n                this.__entries__.push([key, value]);\n            }\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.delete = function (key) {\n            var entries = this.__entries__;\n            var index = getIndex(entries, key);\n\n            if (~index) {\n                entries.splice(index, 1);\n            }\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.has = function (key) {\n            return !!~getIndex(this.__entries__, key);\n        };\n\n        /**\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.clear = function () {\n            this.__entries__.splice(0);\n        };\n\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.forEach = function (callback, ctx) {\n            var this$1 = this;\n            if ( ctx === void 0 ) ctx = null;\n\n            for (var i = 0, list = this$1.__entries__; i < list.length; i += 1) {\n                var entry = list[i];\n\n                callback.call(ctx, entry[1], entry[0]);\n            }\n        };\n\n        Object.defineProperties( anonymous.prototype, prototypeAccessors );\n\n        return anonymous;\n    }());\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\nvar global$1 = (function () {\n    if (typeof global !== 'undefined' && global.Math === Math) {\n        return global;\n    }\n\n    if (typeof self !== 'undefined' && self.Math === Math) {\n        return self;\n    }\n\n    if (typeof window !== 'undefined' && window.Math === Math) {\n        return window;\n    }\n\n    // eslint-disable-next-line no-new-func\n    return Function('return this')();\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\nvar requestAnimationFrame$1 = (function () {\n    if (typeof requestAnimationFrame === 'function') {\n        // It's required to use a bounded function because IE sometimes throws\n        // an \"Invalid calling object\" error if rAF is invoked without the global\n        // object on the left hand side.\n        return requestAnimationFrame.bind(global$1);\n    }\n\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\n})();\n\n// Defines minimum timeout before adding a trailing call.\nvar trailingTimeout = 2;\n\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\nvar throttle = function (callback, delay) {\n    var leadingCall = false,\n        trailingCall = false,\n        lastCallTime = 0;\n\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\n    function resolvePending() {\n        if (leadingCall) {\n            leadingCall = false;\n\n            callback();\n        }\n\n        if (trailingCall) {\n            proxy();\n        }\n    }\n\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\n    function timeoutCallback() {\n        requestAnimationFrame$1(resolvePending);\n    }\n\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\n    function proxy() {\n        var timeStamp = Date.now();\n\n        if (leadingCall) {\n            // Reject immediately following calls.\n            if (timeStamp - lastCallTime < trailingTimeout) {\n                return;\n            }\n\n            // Schedule new call to be in invoked when the pending one is resolved.\n            // This is important for \"transitions\" which never actually start\n            // immediately so there is a chance that we might miss one if change\n            // happens amids the pending invocation.\n            trailingCall = true;\n        } else {\n            leadingCall = true;\n            trailingCall = false;\n\n            setTimeout(timeoutCallback, delay);\n        }\n\n        lastCallTime = timeStamp;\n    }\n\n    return proxy;\n};\n\n// Minimum delay before invoking the update of observers.\nvar REFRESH_DELAY = 20;\n\n// A list of substrings of CSS properties used to find transition events that\n// might affect dimensions of observed elements.\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\n\n// Check if MutationObserver is available.\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\n\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\nvar ResizeObserverController = function() {\n    this.connected_ = false;\n    this.mutationEventsAdded_ = false;\n    this.mutationsObserver_ = null;\n    this.observers_ = [];\n\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n};\n\n/**\r\n * Adds observer to observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be added.\r\n * @returns {void}\r\n */\n\n\n/**\r\n * Holds reference to the controller's instance.\r\n *\r\n * @private {ResizeObserverController}\r\n */\n\n\n/**\r\n * Keeps reference to the instance of MutationObserver.\r\n *\r\n * @private {MutationObserver}\r\n */\n\n/**\r\n * Indicates whether DOM listeners have been added.\r\n *\r\n * @private {boolean}\r\n */\nResizeObserverController.prototype.addObserver = function (observer) {\n    if (!~this.observers_.indexOf(observer)) {\n        this.observers_.push(observer);\n    }\n\n    // Add listeners if they haven't been added yet.\n    if (!this.connected_) {\n        this.connect_();\n    }\n};\n\n/**\r\n * Removes observer from observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.removeObserver = function (observer) {\n    var observers = this.observers_;\n    var index = observers.indexOf(observer);\n\n    // Remove observer if it's present in registry.\n    if (~index) {\n        observers.splice(index, 1);\n    }\n\n    // Remove listeners if controller has no connected observers.\n    if (!observers.length && this.connected_) {\n        this.disconnect_();\n    }\n};\n\n/**\r\n * Invokes the update of observers. It will continue running updates insofar\r\n * it detects changes.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.refresh = function () {\n    var changesDetected = this.updateObservers_();\n\n    // Continue running updates if changes have been detected as there might\n    // be future ones caused by CSS transitions.\n    if (changesDetected) {\n        this.refresh();\n    }\n};\n\n/**\r\n * Updates every observer from observers list and notifies them of queued\r\n * entries.\r\n *\r\n * @private\r\n * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n *  dimensions of it's elements.\r\n */\nResizeObserverController.prototype.updateObservers_ = function () {\n    // Collect observers that have active observations.\n    var activeObservers = this.observers_.filter(function (observer) {\n        return observer.gatherActive(), observer.hasActive();\n    });\n\n    // Deliver notifications in a separate cycle in order to avoid any\n    // collisions between observers, e.g. when multiple instances of\n    // ResizeObserver are tracking the same element and the callback of one\n    // of them changes content dimensions of the observed target. Sometimes\n    // this may result in notifications being blocked for the rest of observers.\n    activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\n\n    return activeObservers.length > 0;\n};\n\n/**\r\n * Initializes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.connect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already added.\n    if (!isBrowser || this.connected_) {\n        return;\n    }\n\n    // Subscription to the \"Transitionend\" event is used as a workaround for\n    // delayed transitions. This way it's possible to capture at least the\n    // final state of an element.\n    document.addEventListener('transitionend', this.onTransitionEnd_);\n\n    window.addEventListener('resize', this.refresh);\n\n    if (mutationObserverSupported) {\n        this.mutationsObserver_ = new MutationObserver(this.refresh);\n\n        this.mutationsObserver_.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true\n        });\n    } else {\n        document.addEventListener('DOMSubtreeModified', this.refresh);\n\n        this.mutationEventsAdded_ = true;\n    }\n\n    this.connected_ = true;\n};\n\n/**\r\n * Removes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.disconnect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already removed.\n    if (!isBrowser || !this.connected_) {\n        return;\n    }\n\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\n    window.removeEventListener('resize', this.refresh);\n\n    if (this.mutationsObserver_) {\n        this.mutationsObserver_.disconnect();\n    }\n\n    if (this.mutationEventsAdded_) {\n        document.removeEventListener('DOMSubtreeModified', this.refresh);\n    }\n\n    this.mutationsObserver_ = null;\n    this.mutationEventsAdded_ = false;\n    this.connected_ = false;\n};\n\n/**\r\n * \"Transitionend\" event handler.\r\n *\r\n * @private\r\n * @param {TransitionEvent} event\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.onTransitionEnd_ = function (ref) {\n        var propertyName = ref.propertyName; if ( propertyName === void 0 ) propertyName = '';\n\n    // Detect whether transition may affect dimensions of an element.\n    var isReflowProperty = transitionKeys.some(function (key) {\n        return !!~propertyName.indexOf(key);\n    });\n\n    if (isReflowProperty) {\n        this.refresh();\n    }\n};\n\n/**\r\n * Returns instance of the ResizeObserverController.\r\n *\r\n * @returns {ResizeObserverController}\r\n */\nResizeObserverController.getInstance = function () {\n    if (!this.instance_) {\n        this.instance_ = new ResizeObserverController();\n    }\n\n    return this.instance_;\n};\n\nResizeObserverController.instance_ = null;\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\nvar defineConfigurable = (function (target, props) {\n    for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {\n        var key = list[i];\n\n        Object.defineProperty(target, key, {\n            value: props[key],\n            enumerable: false,\n            writable: false,\n            configurable: true\n        });\n    }\n\n    return target;\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\nvar getWindowOf = (function (target) {\n    // Assume that the element is an instance of Node, which means that it\n    // has the \"ownerDocument\" property from which we can retrieve a\n    // corresponding global object.\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n\n    // Return the local global object if it's not possible extract one from\n    // provided element.\n    return ownerGlobal || global$1;\n});\n\n// Placeholder of an empty content rectangle.\nvar emptyRect = createRectInit(0, 0, 0, 0);\n\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\nfunction toFloat(value) {\n    return parseFloat(value) || 0;\n}\n\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\nfunction getBordersSize(styles) {\n    var positions = [], len = arguments.length - 1;\n    while ( len-- > 0 ) positions[ len ] = arguments[ len + 1 ];\n\n    return positions.reduce(function (size, position) {\n        var value = styles['border-' + position + '-width'];\n\n        return size + toFloat(value);\n    }, 0);\n}\n\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\nfunction getPaddings(styles) {\n    var positions = ['top', 'right', 'bottom', 'left'];\n    var paddings = {};\n\n    for (var i = 0, list = positions; i < list.length; i += 1) {\n        var position = list[i];\n\n        var value = styles['padding-' + position];\n\n        paddings[position] = toFloat(value);\n    }\n\n    return paddings;\n}\n\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getSVGContentRect(target) {\n    var bbox = target.getBBox();\n\n    return createRectInit(0, 0, bbox.width, bbox.height);\n}\n\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\nfunction getHTMLElementContentRect(target) {\n    // Client width & height properties can't be\n    // used exclusively as they provide rounded values.\n    var clientWidth = target.clientWidth;\n    var clientHeight = target.clientHeight;\n\n    // By this condition we can catch all non-replaced inline, hidden and\n    // detached elements. Though elements with width & height properties less\n    // than 0.5 will be discarded as well.\n    //\n    // Without it we would need to implement separate methods for each of\n    // those cases and it's not possible to perform a precise and performance\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\n    // gives wrong results for elements with width & height less than 0.5.\n    if (!clientWidth && !clientHeight) {\n        return emptyRect;\n    }\n\n    var styles = getWindowOf(target).getComputedStyle(target);\n    var paddings = getPaddings(styles);\n    var horizPad = paddings.left + paddings.right;\n    var vertPad = paddings.top + paddings.bottom;\n\n    // Computed styles of width & height are being used because they are the\n    // only dimensions available to JS that contain non-rounded values. It could\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\n    var width = toFloat(styles.width),\n        height = toFloat(styles.height);\n\n    // Width & height include paddings and borders when the 'border-box' box\n    // model is applied (except for IE).\n    if (styles.boxSizing === 'border-box') {\n        // Following conditions are required to handle Internet Explorer which\n        // doesn't include paddings and borders to computed CSS dimensions.\n        //\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\n        // properties then it's either IE, and thus we don't need to subtract\n        // anything, or an element merely doesn't have paddings/borders styles.\n        if (Math.round(width + horizPad) !== clientWidth) {\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\n        }\n\n        if (Math.round(height + vertPad) !== clientHeight) {\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\n        }\n    }\n\n    // Following steps can't be applied to the document's root element as its\n    // client[Width/Height] properties represent viewport area of the window.\n    // Besides, it's as well not necessary as the <html> itself neither has\n    // rendered scroll bars nor it can be clipped.\n    if (!isDocumentElement(target)) {\n        // In some browsers (only in Firefox, actually) CSS width & height\n        // include scroll bars size which can be removed at this step as scroll\n        // bars are the only difference between rounded dimensions + paddings\n        // and \"client\" properties, though that is not always true in Chrome.\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n\n        // Chrome has a rather weird rounding of \"client\" properties.\n        // E.g. for an element with content width of 314.2px it sometimes gives\n        // the client width of 315px and for the width of 314.7px it may give\n        // 314px. And it doesn't happen all the time. So just ignore this delta\n        // as a non-relevant.\n        if (Math.abs(vertScrollbar) !== 1) {\n            width -= vertScrollbar;\n        }\n\n        if (Math.abs(horizScrollbar) !== 1) {\n            height -= horizScrollbar;\n        }\n    }\n\n    return createRectInit(paddings.left, paddings.top, width, height);\n}\n\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nvar isSVGGraphicsElement = (function () {\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\n    // interface.\n    if (typeof SVGGraphicsElement !== 'undefined') {\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\n    }\n\n    // If it's so, then check that element is at least an instance of the\n    // SVGElement and that it has the \"getBBox\" method.\n    // eslint-disable-next-line no-extra-parens\n    return function (target) { return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function'; };\n})();\n\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nfunction isDocumentElement(target) {\n    return target === getWindowOf(target).document.documentElement;\n}\n\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getContentRect(target) {\n    if (!isBrowser) {\n        return emptyRect;\n    }\n\n    if (isSVGGraphicsElement(target)) {\n        return getSVGContentRect(target);\n    }\n\n    return getHTMLElementContentRect(target);\n}\n\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\nfunction createReadOnlyRect(ref) {\n    var x = ref.x;\n    var y = ref.y;\n    var width = ref.width;\n    var height = ref.height;\n\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\n    var rect = Object.create(Constr.prototype);\n\n    // Rectangle's properties are not writable and non-enumerable.\n    defineConfigurable(rect, {\n        x: x, y: y, width: width, height: height,\n        top: y,\n        right: x + width,\n        bottom: height + y,\n        left: x\n    });\n\n    return rect;\n}\n\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\nfunction createRectInit(x, y, width, height) {\n    return { x: x, y: y, width: width, height: height };\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\nvar ResizeObservation = function(target) {\n    this.broadcastWidth = 0;\n    this.broadcastHeight = 0;\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\n\n    this.target = target;\n};\n\n/**\r\n * Updates content rectangle and tells whether it's width or height properties\r\n * have changed since the last broadcast.\r\n *\r\n * @returns {boolean}\r\n */\n\n\n/**\r\n * Reference to the last observed content rectangle.\r\n *\r\n * @private {DOMRectInit}\r\n */\n\n\n/**\r\n * Broadcasted width of content rectangle.\r\n *\r\n * @type {number}\r\n */\nResizeObservation.prototype.isActive = function () {\n    var rect = getContentRect(this.target);\n\n    this.contentRect_ = rect;\n\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n};\n\n/**\r\n * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n * from the corresponding properties of the last observed content rectangle.\r\n *\r\n * @returns {DOMRectInit} Last observed content rectangle.\r\n */\nResizeObservation.prototype.broadcastRect = function () {\n    var rect = this.contentRect_;\n\n    this.broadcastWidth = rect.width;\n    this.broadcastHeight = rect.height;\n\n    return rect;\n};\n\nvar ResizeObserverEntry = function(target, rectInit) {\n    var contentRect = createReadOnlyRect(rectInit);\n\n    // According to the specification following properties are not writable\n    // and are also not enumerable in the native implementation.\n    //\n    // Property accessors are not being used as they'd require to define a\n    // private WeakMap storage which may cause memory leaks in browsers that\n    // don't support this type of collections.\n    defineConfigurable(this, { target: target, contentRect: contentRect });\n};\n\nvar ResizeObserverSPI = function(callback, controller, callbackCtx) {\n    this.activeObservations_ = [];\n    this.observations_ = new MapShim();\n\n    if (typeof callback !== 'function') {\n        throw new TypeError('The callback provided as parameter 1 is not a function.');\n    }\n\n    this.callback_ = callback;\n    this.controller_ = controller;\n    this.callbackCtx_ = callbackCtx;\n};\n\n/**\r\n * Starts observing provided element.\r\n *\r\n * @param {Element} target - Element to be observed.\r\n * @returns {void}\r\n */\n\n\n/**\r\n * Registry of the ResizeObservation instances.\r\n *\r\n * @private {Map<Element, ResizeObservation>}\r\n */\n\n\n/**\r\n * Public ResizeObserver instance which will be passed to the callback\r\n * function and used as a value of it's \"this\" binding.\r\n *\r\n * @private {ResizeObserver}\r\n */\n\n/**\r\n * Collection of resize observations that have detected changes in dimensions\r\n * of elements.\r\n *\r\n * @private {Array<ResizeObservation>}\r\n */\nResizeObserverSPI.prototype.observe = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is already being observed.\n    if (observations.has(target)) {\n        return;\n    }\n\n    observations.set(target, new ResizeObservation(target));\n\n    this.controller_.addObserver(this);\n\n    // Force the update of observations.\n    this.controller_.refresh();\n};\n\n/**\r\n * Stops observing provided element.\r\n *\r\n * @param {Element} target - Element to stop observing.\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.unobserve = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is not being observed.\n    if (!observations.has(target)) {\n        return;\n    }\n\n    observations.delete(target);\n\n    if (!observations.size) {\n        this.controller_.removeObserver(this);\n    }\n};\n\n/**\r\n * Stops observing all elements.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.disconnect = function () {\n    this.clearActive();\n    this.observations_.clear();\n    this.controller_.removeObserver(this);\n};\n\n/**\r\n * Collects observation instances the associated element of which has changed\r\n * it's content rectangle.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.gatherActive = function () {\n        var this$1 = this;\n\n    this.clearActive();\n\n    this.observations_.forEach(function (observation) {\n        if (observation.isActive()) {\n            this$1.activeObservations_.push(observation);\n        }\n    });\n};\n\n/**\r\n * Invokes initial callback function with a list of ResizeObserverEntry\r\n * instances collected from active resize observations.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.broadcastActive = function () {\n    // Do nothing if observer doesn't have active observations.\n    if (!this.hasActive()) {\n        return;\n    }\n\n    var ctx = this.callbackCtx_;\n\n    // Create ResizeObserverEntry instance for every active observation.\n    var entries = this.activeObservations_.map(function (observation) {\n        return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n    });\n\n    this.callback_.call(ctx, entries, ctx);\n    this.clearActive();\n};\n\n/**\r\n * Clears the collection of active observations.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.clearActive = function () {\n    this.activeObservations_.splice(0);\n};\n\n/**\r\n * Tells whether observer has active observations.\r\n *\r\n * @returns {boolean}\r\n */\nResizeObserverSPI.prototype.hasActive = function () {\n    return this.activeObservations_.length > 0;\n};\n\n// Registry of internal observers. If WeakMap is not available use current shim\n// for the Map collection as it has all required methods and because WeakMap\n// can't be fully polyfilled anyway.\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\n\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\nvar ResizeObserver = function(callback) {\n    if (!(this instanceof ResizeObserver)) {\n        throw new TypeError('Cannot call a class as a function.');\n    }\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    var controller = ResizeObserverController.getInstance();\n    var observer = new ResizeObserverSPI(callback, controller, this);\n\n    observers.set(this, observer);\n};\n\n// Expose public methods of ResizeObserver.\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\n    ResizeObserver.prototype[method] = function () {\n        return (ref = observers.get(this))[method].apply(ref, arguments);\n        var ref;\n    };\n});\n\nvar index = (function () {\n    // Export existing implementation if available.\n    if (typeof global$1.ResizeObserver !== 'undefined') {\n        return global$1.ResizeObserver;\n    }\n\n    return ResizeObserver;\n})();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (index);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(6)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// react-truncate-markup.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9a3c38d6124b58be8e30","import React from 'react';\nimport PropTypes from 'prop-types';\nimport getLineHeight from 'line-height';\nimport ResizeObserver from 'resize-observer-polyfill';\n\nconst SPLIT = {\n  LEFT: true,\n  RIGHT: false,\n};\n\nconst toString = (node, string = '') => {\n  if (!node) {\n    return string;\n  } else if (typeof node === 'string') {\n    return string + node;\n  } else if (Array.isArray(node)) {\n    let newString = string;\n    node.forEach(child => {\n      newString = toString(child, newString);\n    });\n\n    return newString;\n  }\n\n  return toString(node.props.children, string);\n};\n\nconst cloneWithChildren = (node, children, isRootEl, level) => ({\n  ...node,\n  props: {\n    ...node.props,\n    style: {\n      ...node.props.style,\n      ...(isRootEl\n        ? {\n            // root element cannot be an inline element because of the line calculation\n            display: (node.props.style || {}).display || 'block',\n          }\n        : level === 2\n          ? {\n              // level 2 elements (direct children of the root element) need to be inline because of the ellipsis.\n              // if level 2 element was a block element, ellipsis would get rendered on a new line, breaking the max number of lines\n              display: (node.props.style || {}).display || 'inline-block',\n            }\n          : {}),\n    },\n    children,\n  },\n});\n\nconst validateTree = node => {\n  if (typeof node === 'string') {\n    return true;\n  } else if (typeof node.type === 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      /* eslint-disable no-console */\n      console.error(\n        `ReactTruncateMarkup tried to render <${node.type\n          .name} />, but truncating React components is not supported, the full content is rendered instead. Only DOM elements are supported.`,\n      );\n      /* eslint-enable */\n    }\n\n    return false;\n  }\n\n  if (node.props.children) {\n    if (Array.isArray(node.props.children)) {\n      return node.props.children.reduce(\n        (isValid, child) => isValid && validateTree(child),\n        true,\n      );\n    }\n\n    return validateTree(node.props.children);\n  }\n\n  return true;\n};\n\nexport default class TruncateMarkup extends React.Component {\n  static propTypes = {\n    children: PropTypes.element.isRequired,\n    lines: PropTypes.number,\n    ellipsis: PropTypes.oneOfType([\n      PropTypes.element,\n      PropTypes.string,\n      PropTypes.func,\n    ]),\n    lineHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    onAfterTruncate: PropTypes.func,\n  };\n\n  static defaultProps = {\n    lines: 1,\n    ellipsis: '...',\n    lineHeight: '',\n    onAfterTruncate: () => {},\n  };\n\n  state = {\n    text: this.childrenElementWithRef(this.props.children),\n  };\n\n  isValid = validateTree(this.props.children);\n  lineHeight = null;\n  splitDirectionSeq = [];\n  shouldTruncate = true;\n  wasLastCharTested = false;\n  endFound = false;\n  latestThatFits = null;\n  origText = null;\n  clientWidth = null;\n  onAfterTruncateCalled = false;\n\n  componentDidMount() {\n    if (!this.isValid) {\n      return;\n    }\n\n    this.origText = this.state.text;\n\n    // get the computed line-height of the parent element\n    // it'll be used for determining whether the text fits the container or not\n    this.lineHeight = this.props.lineHeight || getLineHeight(this.el);\n\n    this.truncate();\n\n    this.handleResize();\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    this.shouldTruncate = false;\n    this.latestThatFits = null;\n    this.isValid = validateTree(nextProps.children);\n\n    this.setState(\n      {\n        text: this.childrenElementWithRef(nextProps.children),\n      },\n      () => {\n        if (!this.isValid) {\n          return;\n        }\n\n        this.origText = this.state.text;\n        this.lineHeight = nextProps.lineHeight || getLineHeight(this.el);\n        this.shouldTruncate = true;\n        this.truncate();\n\n        this.handleResize();\n      },\n    );\n  }\n\n  componentDidUpdate() {\n    if (this.shouldTruncate === false || this.isValid === false) {\n      return;\n    }\n\n    if (this.endFound) {\n      // we've found the end where we cannot split the text further\n      // that means we've already found the max subtree that fits the container\n      // so we are rendering that\n      if (this.state.text !== this.latestThatFits) {\n        /* eslint-disable react/no-did-update-set-state */\n        this.setState({\n          text: this.latestThatFits,\n        });\n\n        return;\n        /* eslint-enable */\n      } else if (this.el && this.el.clientWidth !== this.clientWidth) {\n        // edge case - scrollbar (dis?)appearing might mess up the container width\n        // causing strings that would normally fit on X lines to suddenly take up X+1 lines\n        // ugly fix - recalculate again\n        this.truncateOriginalText();\n\n        return;\n      }\n\n      this.onAfterTruncate(/* wasTruncated */ true);\n\n      return;\n    }\n\n    if (this.splitDirectionSeq.length) {\n      if (this.fits()) {\n        this.latestThatFits = this.state.text;\n        this.clientWidth = this.el.clientWidth;\n        // we've found a subtree that fits the container\n        // but we need to check if we didn't cut too much of it off\n        // so we are changing the last splitting decision from splitting and going left\n        // to splitting and going right\n        this.splitDirectionSeq.splice(\n          this.splitDirectionSeq.length - 1,\n          1,\n          SPLIT.RIGHT,\n          SPLIT.LEFT,\n        );\n      } else {\n        this.splitDirectionSeq.push(SPLIT.LEFT);\n      }\n\n      this.tryToFit(this.origText, this.splitDirectionSeq);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    this.lineHeight = null;\n    this.origText = null;\n    this.latestThatFits = null;\n    this.splitDirectionSeq = [];\n  }\n\n  onAfterTruncate = wasTruncated => {\n    if (!this.onAfterTruncateCalled) {\n      this.onAfterTruncateCalled = true;\n      this.props.onAfterTruncate(wasTruncated);\n    }\n  };\n\n  handleResize = () => {\n    /* Wrapper element resize handing */\n    let initialRender = true;\n\n    this.resizeObserver = new ResizeObserver(() => {\n      if (initialRender) {\n        // ResizeObserer cb is called on initial render too so we are skipping here\n        initialRender = false;\n      } else {\n        // wrapper element has been resized, recalculating with the original text\n        this.shouldTruncate = false;\n        this.latestThatFits = null;\n\n        this.setState(\n          {\n            text: this.origText,\n          },\n          () => {\n            this.shouldTruncate = true;\n            this.onAfterTruncateCalled = false;\n            this.truncate();\n          },\n        );\n      }\n    });\n\n    this.resizeObserver.observe(this.el);\n  };\n\n  truncate() {\n    if (this.fits()) {\n      // the whole text fits on the first try, no need to do anything else\n      this.shouldTruncate = false;\n      this.onAfterTruncate(/* wasTruncated */ false);\n\n      return;\n    }\n\n    this.truncateOriginalText();\n  }\n\n  childrenElementWithRef(children) {\n    const child = React.Children.only(children);\n\n    return React.cloneElement(child, { ref: el => (this.el = el) });\n  }\n\n  truncateOriginalText() {\n    this.endFound = false;\n    this.splitDirectionSeq = [SPLIT.LEFT];\n    this.wasLastCharTested = false;\n\n    this.tryToFit(this.origText, this.splitDirectionSeq);\n  }\n\n  /**\n   * Splits rootEl based on instructions and updates React's state with the returned element\n   * After React rerenders the new text, we'll check if the new text fits in componentDidUpdate\n   * @param  {ReactElement} rootEl - the original children element\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   */\n  tryToFit(rootEl, splitDirections) {\n    if (!rootEl.props.children) {\n      // no markup in container\n      return;\n    }\n\n    const newRootEl = this.split(rootEl, splitDirections, /* isRootEl */ true);\n\n    let ellipsis =\n      typeof this.props.ellipsis === 'function'\n        ? this.props.ellipsis(newRootEl)\n        : this.props.ellipsis;\n\n    ellipsis =\n      typeof ellipsis === 'object'\n        ? React.cloneElement(ellipsis, { key: 'ellipsis' })\n        : ellipsis;\n\n    const newChildren = newRootEl.props.children;\n    const newChildrenWithEllipsis = Array.isArray(newChildren)\n      ? [...newChildren, ellipsis]\n      : [newChildren, ellipsis];\n\n    // edge case tradeoff EC#1 - on initial render it doesn't fit in the requested number of lines (1) so it starts truncating\n    // - because of truncating and the ellipsis position, div#lvl2 will have display set to 'inline-block',\n    //   causing the whole body to fit in 1 line again\n    // - if that happens, ellipsis is not needed anymore as the whole body is rendered\n    // - NOTE this could be fixed by checking for this exact case and handling it separately so it renders <div>foo {ellipsis}</div>\n    //\n    // Example:\n    // <TruncateMarkup lines={1}>\n    //   <div>\n    //     foo\n    //     <div id=\"lvl2\">bar</div>\n    //   </div>\n    // </TruncateMarkup>\n    const shouldRenderEllipsis =\n      toString(newChildren) !== toString(this.origText);\n\n    this.setState({\n      text: {\n        ...newRootEl,\n        props: {\n          ...newRootEl.props,\n          style: {\n            wordWrap: 'break-word',\n            ...newRootEl.props.style,\n          },\n          children: shouldRenderEllipsis\n            ? newChildrenWithEllipsis\n            : newChildren,\n        },\n      },\n    });\n  }\n\n  /**\n   * Splits JSX node based on its type\n   * @param  {null|string|Array|Object} node - JSX node\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   * @return {null|string|Array|Object} - split JSX node\n   */\n  split(node, splitDirections, isRoot = false, level = 1) {\n    if (!node) {\n      return node;\n    } else if (typeof node === 'string') {\n      return this.splitString(node, splitDirections);\n    } else if (Array.isArray(node)) {\n      return this.splitArray(node, splitDirections, level);\n    }\n\n    const newChildren = this.split(\n      node.props.children,\n      splitDirections,\n      /* isRoot */ false,\n      level + 1,\n    );\n\n    return cloneWithChildren(node, newChildren, isRoot, level);\n  }\n\n  splitString(string, splitDirections = []) {\n    if (!splitDirections.length) {\n      return string;\n    }\n\n    if (splitDirections.length && string.length === 1) {\n      // allow for an extra render test with the current character included\n      // in most cases this variation was already tested, but some edge cases require this check\n      // NOTE could be removed once EC#1 is taken care of\n      if (!this.wasLastCharTested) {\n        this.wasLastCharTested = true;\n      } else {\n        // we are trying to split further but we have nowhere to go now\n        // that means we've already found the max subtree that fits the container\n        this.endFound = true;\n      }\n\n      return string;\n    }\n\n    const [splitDirection, ...restSplitDirections] = splitDirections;\n    const pivotIndex = Math.ceil(string.length / 2);\n\n    if (splitDirection === SPLIT.LEFT) {\n      const subString = string.substring(0, pivotIndex);\n\n      return this.splitString(subString, restSplitDirections);\n    }\n    const beforeString = string.substring(0, pivotIndex);\n    const afterString = string.substring(pivotIndex);\n\n    return beforeString + this.splitString(afterString, restSplitDirections);\n  }\n\n  splitArray(array, splitDirections = [], level) {\n    if (!splitDirections.length) {\n      return array;\n    }\n\n    if (array.length === 1) {\n      const [item] = array;\n\n      if (typeof item === 'string') {\n        return [this.splitString(item, splitDirections)];\n      }\n      const { children } = item.props;\n\n      const newChildren = this.split(\n        children,\n        splitDirections,\n        /* isRoot */ false,\n        level + 1,\n      );\n\n      return [cloneWithChildren(item, newChildren, /* isRoot */ false, level)];\n    }\n\n    const [splitDirection, ...restSplitDirections] = splitDirections;\n    const pivotIndex = Math.ceil(array.length / 2);\n\n    if (splitDirection === SPLIT.LEFT) {\n      const subArray = array.slice(0, pivotIndex);\n\n      return this.splitArray(subArray, restSplitDirections, level);\n    }\n    const beforeArray = array.slice(0, pivotIndex);\n    const afterArray = array.slice(pivotIndex);\n\n    return beforeArray.concat(\n      this.splitArray(afterArray, restSplitDirections, level),\n    );\n  }\n\n  fits() {\n    const { lines: maxLines } = this.props;\n    const { height } = this.el.getBoundingClientRect();\n    const computedLines = Math.round(height / parseFloat(this.lineHeight));\n\n    if (process.env.NODE_ENV !== 'production' && computedLines <= 0) {\n      /* eslint-disable no-console */\n      console.warn(\n        `ReactTruncateMarkup: number of currently rendered lines: ${computedLines}, not truncating...\n  It may be caused by target element not being visible at the time of computation.`,\n      );\n      /* eslint-enable */\n    }\n\n    return maxLines >= computedLines;\n  }\n\n  render() {\n    return this.state.text;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 2\n// module chunks = 0","// Load in dependencies\nvar computedStyle = require('computed-style');\n\n/**\n * Calculate the `line-height` of a given node\n * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.\n * @returns {Number} `line-height` of the element in pixels\n */\nfunction lineHeight(node) {\n  // Grab the line-height via style\n  var lnHeightStr = computedStyle(node, 'line-height');\n  var lnHeight = parseFloat(lnHeightStr, 10);\n\n  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')\n  if (lnHeightStr === lnHeight + '') {\n    // Save the old lineHeight style and update the em unit to the element\n    var _lnHeightStyle = node.style.lineHeight;\n    node.style.lineHeight = lnHeightStr + 'em';\n\n    // Calculate the em based height\n    lnHeightStr = computedStyle(node, 'line-height');\n    lnHeight = parseFloat(lnHeightStr, 10);\n\n    // Revert the lineHeight style\n    if (_lnHeightStyle) {\n      node.style.lineHeight = _lnHeightStyle;\n    } else {\n      delete node.style.lineHeight;\n    }\n  }\n\n  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)\n  // DEV: `em` units are converted to `pt` in IE6\n  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length\n  if (lnHeightStr.indexOf('pt') !== -1) {\n    lnHeight *= 4;\n    lnHeight /= 3;\n  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)\n  } else if (lnHeightStr.indexOf('mm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 25.4;\n  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)\n  } else if (lnHeightStr.indexOf('cm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 2.54;\n  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)\n  } else if (lnHeightStr.indexOf('in') !== -1) {\n    lnHeight *= 96;\n  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)\n  } else if (lnHeightStr.indexOf('pc') !== -1) {\n    lnHeight *= 16;\n  }\n\n  // Continue our computation\n  lnHeight = Math.round(lnHeight);\n\n  // If the line-height is \"normal\", calculate by font-size\n  if (lnHeightStr === 'normal') {\n    // Create a temporary node\n    var nodeName = node.nodeName;\n    var _node = document.createElement(nodeName);\n    _node.innerHTML = '&nbsp;';\n\n    // If we have a text area, reset it to only 1 row\n    // https://github.com/twolfson/line-height/issues/4\n    if (nodeName.toUpperCase() === 'TEXTAREA') {\n      _node.setAttribute('rows', '1');\n    }\n\n    // Set the font-size of the element\n    var fontSizeStr = computedStyle(node, 'font-size');\n    _node.style.fontSize = fontSizeStr;\n\n    // Remove default padding/border which can affect offset height\n    // https://github.com/twolfson/line-height/issues/4\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    _node.style.padding = '0px';\n    _node.style.border = '0px';\n\n    // Append it to the body\n    var body = document.body;\n    body.appendChild(_node);\n\n    // Assume the line height of the element is the height\n    var height = _node.offsetHeight;\n    lnHeight = height;\n\n    // Remove our child from the DOM\n    body.removeChild(_node);\n  }\n\n  // Return the calculated height\n  return lnHeight;\n}\n\n// Export lineHeight\nmodule.exports = lineHeight;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/line-height/lib/line-height.js\n// module id = 3\n// module chunks = 0","// This code has been refactored for 140 bytes\n// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js\nvar computedStyle = function (el, prop, getComputedStyle) {\n  getComputedStyle = window.getComputedStyle;\n\n  // In one fell swoop\n  return (\n    // If we have getComputedStyle\n    getComputedStyle ?\n      // Query it\n      // TODO: From CSS-Query notes, we might need (node, null) for FF\n      getComputedStyle(el) :\n\n    // Otherwise, we are in IE and use currentStyle\n      el.currentStyle\n  )[\n    // Switch to camelCase for CSSOM\n    // DEV: Grabbed from jQuery\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597\n    prop.replace(/-(\\w)/gi, function (word, letter) {\n      return letter.toUpperCase();\n    })\n  ];\n};\n\nmodule.exports = computedStyle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/computed-style/dist/computedStyle.commonjs.js\n// module id = 4\n// module chunks = 0","/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\n/* eslint-disable require-jsdoc, valid-jsdoc */\nvar MapShim = (function () {\n    if (typeof Map !== 'undefined') {\n        return Map;\n    }\n\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\n    function getIndex(arr, key) {\n        var result = -1;\n\n        arr.some(function (entry, index) {\n            if (entry[0] === key) {\n                result = index;\n\n                return true;\n            }\n\n            return false;\n        });\n\n        return result;\n    }\n\n    return (function () {\n        function anonymous() {\n            this.__entries__ = [];\n        }\n\n        var prototypeAccessors = { size: { configurable: true } };\n\n        /**\r\n         * @returns {boolean}\r\n         */\n        prototypeAccessors.size.get = function () {\n            return this.__entries__.length;\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\n        anonymous.prototype.get = function (key) {\n            var index = getIndex(this.__entries__, key);\n            var entry = this.__entries__[index];\n\n            return entry && entry[1];\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.set = function (key, value) {\n            var index = getIndex(this.__entries__, key);\n\n            if (~index) {\n                this.__entries__[index][1] = value;\n            } else {\n                this.__entries__.push([key, value]);\n            }\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.delete = function (key) {\n            var entries = this.__entries__;\n            var index = getIndex(entries, key);\n\n            if (~index) {\n                entries.splice(index, 1);\n            }\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.has = function (key) {\n            return !!~getIndex(this.__entries__, key);\n        };\n\n        /**\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.clear = function () {\n            this.__entries__.splice(0);\n        };\n\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.forEach = function (callback, ctx) {\n            var this$1 = this;\n            if ( ctx === void 0 ) ctx = null;\n\n            for (var i = 0, list = this$1.__entries__; i < list.length; i += 1) {\n                var entry = list[i];\n\n                callback.call(ctx, entry[1], entry[0]);\n            }\n        };\n\n        Object.defineProperties( anonymous.prototype, prototypeAccessors );\n\n        return anonymous;\n    }());\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\nvar global$1 = (function () {\n    if (typeof global !== 'undefined' && global.Math === Math) {\n        return global;\n    }\n\n    if (typeof self !== 'undefined' && self.Math === Math) {\n        return self;\n    }\n\n    if (typeof window !== 'undefined' && window.Math === Math) {\n        return window;\n    }\n\n    // eslint-disable-next-line no-new-func\n    return Function('return this')();\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\nvar requestAnimationFrame$1 = (function () {\n    if (typeof requestAnimationFrame === 'function') {\n        // It's required to use a bounded function because IE sometimes throws\n        // an \"Invalid calling object\" error if rAF is invoked without the global\n        // object on the left hand side.\n        return requestAnimationFrame.bind(global$1);\n    }\n\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\n})();\n\n// Defines minimum timeout before adding a trailing call.\nvar trailingTimeout = 2;\n\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\nvar throttle = function (callback, delay) {\n    var leadingCall = false,\n        trailingCall = false,\n        lastCallTime = 0;\n\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\n    function resolvePending() {\n        if (leadingCall) {\n            leadingCall = false;\n\n            callback();\n        }\n\n        if (trailingCall) {\n            proxy();\n        }\n    }\n\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\n    function timeoutCallback() {\n        requestAnimationFrame$1(resolvePending);\n    }\n\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\n    function proxy() {\n        var timeStamp = Date.now();\n\n        if (leadingCall) {\n            // Reject immediately following calls.\n            if (timeStamp - lastCallTime < trailingTimeout) {\n                return;\n            }\n\n            // Schedule new call to be in invoked when the pending one is resolved.\n            // This is important for \"transitions\" which never actually start\n            // immediately so there is a chance that we might miss one if change\n            // happens amids the pending invocation.\n            trailingCall = true;\n        } else {\n            leadingCall = true;\n            trailingCall = false;\n\n            setTimeout(timeoutCallback, delay);\n        }\n\n        lastCallTime = timeStamp;\n    }\n\n    return proxy;\n};\n\n// Minimum delay before invoking the update of observers.\nvar REFRESH_DELAY = 20;\n\n// A list of substrings of CSS properties used to find transition events that\n// might affect dimensions of observed elements.\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\n\n// Check if MutationObserver is available.\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\n\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\nvar ResizeObserverController = function() {\n    this.connected_ = false;\n    this.mutationEventsAdded_ = false;\n    this.mutationsObserver_ = null;\n    this.observers_ = [];\n\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n};\n\n/**\r\n * Adds observer to observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be added.\r\n * @returns {void}\r\n */\n\n\n/**\r\n * Holds reference to the controller's instance.\r\n *\r\n * @private {ResizeObserverController}\r\n */\n\n\n/**\r\n * Keeps reference to the instance of MutationObserver.\r\n *\r\n * @private {MutationObserver}\r\n */\n\n/**\r\n * Indicates whether DOM listeners have been added.\r\n *\r\n * @private {boolean}\r\n */\nResizeObserverController.prototype.addObserver = function (observer) {\n    if (!~this.observers_.indexOf(observer)) {\n        this.observers_.push(observer);\n    }\n\n    // Add listeners if they haven't been added yet.\n    if (!this.connected_) {\n        this.connect_();\n    }\n};\n\n/**\r\n * Removes observer from observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.removeObserver = function (observer) {\n    var observers = this.observers_;\n    var index = observers.indexOf(observer);\n\n    // Remove observer if it's present in registry.\n    if (~index) {\n        observers.splice(index, 1);\n    }\n\n    // Remove listeners if controller has no connected observers.\n    if (!observers.length && this.connected_) {\n        this.disconnect_();\n    }\n};\n\n/**\r\n * Invokes the update of observers. It will continue running updates insofar\r\n * it detects changes.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.refresh = function () {\n    var changesDetected = this.updateObservers_();\n\n    // Continue running updates if changes have been detected as there might\n    // be future ones caused by CSS transitions.\n    if (changesDetected) {\n        this.refresh();\n    }\n};\n\n/**\r\n * Updates every observer from observers list and notifies them of queued\r\n * entries.\r\n *\r\n * @private\r\n * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n *  dimensions of it's elements.\r\n */\nResizeObserverController.prototype.updateObservers_ = function () {\n    // Collect observers that have active observations.\n    var activeObservers = this.observers_.filter(function (observer) {\n        return observer.gatherActive(), observer.hasActive();\n    });\n\n    // Deliver notifications in a separate cycle in order to avoid any\n    // collisions between observers, e.g. when multiple instances of\n    // ResizeObserver are tracking the same element and the callback of one\n    // of them changes content dimensions of the observed target. Sometimes\n    // this may result in notifications being blocked for the rest of observers.\n    activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\n\n    return activeObservers.length > 0;\n};\n\n/**\r\n * Initializes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.connect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already added.\n    if (!isBrowser || this.connected_) {\n        return;\n    }\n\n    // Subscription to the \"Transitionend\" event is used as a workaround for\n    // delayed transitions. This way it's possible to capture at least the\n    // final state of an element.\n    document.addEventListener('transitionend', this.onTransitionEnd_);\n\n    window.addEventListener('resize', this.refresh);\n\n    if (mutationObserverSupported) {\n        this.mutationsObserver_ = new MutationObserver(this.refresh);\n\n        this.mutationsObserver_.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true\n        });\n    } else {\n        document.addEventListener('DOMSubtreeModified', this.refresh);\n\n        this.mutationEventsAdded_ = true;\n    }\n\n    this.connected_ = true;\n};\n\n/**\r\n * Removes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.disconnect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already removed.\n    if (!isBrowser || !this.connected_) {\n        return;\n    }\n\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\n    window.removeEventListener('resize', this.refresh);\n\n    if (this.mutationsObserver_) {\n        this.mutationsObserver_.disconnect();\n    }\n\n    if (this.mutationEventsAdded_) {\n        document.removeEventListener('DOMSubtreeModified', this.refresh);\n    }\n\n    this.mutationsObserver_ = null;\n    this.mutationEventsAdded_ = false;\n    this.connected_ = false;\n};\n\n/**\r\n * \"Transitionend\" event handler.\r\n *\r\n * @private\r\n * @param {TransitionEvent} event\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.onTransitionEnd_ = function (ref) {\n        var propertyName = ref.propertyName; if ( propertyName === void 0 ) propertyName = '';\n\n    // Detect whether transition may affect dimensions of an element.\n    var isReflowProperty = transitionKeys.some(function (key) {\n        return !!~propertyName.indexOf(key);\n    });\n\n    if (isReflowProperty) {\n        this.refresh();\n    }\n};\n\n/**\r\n * Returns instance of the ResizeObserverController.\r\n *\r\n * @returns {ResizeObserverController}\r\n */\nResizeObserverController.getInstance = function () {\n    if (!this.instance_) {\n        this.instance_ = new ResizeObserverController();\n    }\n\n    return this.instance_;\n};\n\nResizeObserverController.instance_ = null;\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\nvar defineConfigurable = (function (target, props) {\n    for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {\n        var key = list[i];\n\n        Object.defineProperty(target, key, {\n            value: props[key],\n            enumerable: false,\n            writable: false,\n            configurable: true\n        });\n    }\n\n    return target;\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\nvar getWindowOf = (function (target) {\n    // Assume that the element is an instance of Node, which means that it\n    // has the \"ownerDocument\" property from which we can retrieve a\n    // corresponding global object.\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n\n    // Return the local global object if it's not possible extract one from\n    // provided element.\n    return ownerGlobal || global$1;\n});\n\n// Placeholder of an empty content rectangle.\nvar emptyRect = createRectInit(0, 0, 0, 0);\n\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\nfunction toFloat(value) {\n    return parseFloat(value) || 0;\n}\n\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\nfunction getBordersSize(styles) {\n    var positions = [], len = arguments.length - 1;\n    while ( len-- > 0 ) positions[ len ] = arguments[ len + 1 ];\n\n    return positions.reduce(function (size, position) {\n        var value = styles['border-' + position + '-width'];\n\n        return size + toFloat(value);\n    }, 0);\n}\n\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\nfunction getPaddings(styles) {\n    var positions = ['top', 'right', 'bottom', 'left'];\n    var paddings = {};\n\n    for (var i = 0, list = positions; i < list.length; i += 1) {\n        var position = list[i];\n\n        var value = styles['padding-' + position];\n\n        paddings[position] = toFloat(value);\n    }\n\n    return paddings;\n}\n\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getSVGContentRect(target) {\n    var bbox = target.getBBox();\n\n    return createRectInit(0, 0, bbox.width, bbox.height);\n}\n\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\nfunction getHTMLElementContentRect(target) {\n    // Client width & height properties can't be\n    // used exclusively as they provide rounded values.\n    var clientWidth = target.clientWidth;\n    var clientHeight = target.clientHeight;\n\n    // By this condition we can catch all non-replaced inline, hidden and\n    // detached elements. Though elements with width & height properties less\n    // than 0.5 will be discarded as well.\n    //\n    // Without it we would need to implement separate methods for each of\n    // those cases and it's not possible to perform a precise and performance\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\n    // gives wrong results for elements with width & height less than 0.5.\n    if (!clientWidth && !clientHeight) {\n        return emptyRect;\n    }\n\n    var styles = getWindowOf(target).getComputedStyle(target);\n    var paddings = getPaddings(styles);\n    var horizPad = paddings.left + paddings.right;\n    var vertPad = paddings.top + paddings.bottom;\n\n    // Computed styles of width & height are being used because they are the\n    // only dimensions available to JS that contain non-rounded values. It could\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\n    var width = toFloat(styles.width),\n        height = toFloat(styles.height);\n\n    // Width & height include paddings and borders when the 'border-box' box\n    // model is applied (except for IE).\n    if (styles.boxSizing === 'border-box') {\n        // Following conditions are required to handle Internet Explorer which\n        // doesn't include paddings and borders to computed CSS dimensions.\n        //\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\n        // properties then it's either IE, and thus we don't need to subtract\n        // anything, or an element merely doesn't have paddings/borders styles.\n        if (Math.round(width + horizPad) !== clientWidth) {\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\n        }\n\n        if (Math.round(height + vertPad) !== clientHeight) {\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\n        }\n    }\n\n    // Following steps can't be applied to the document's root element as its\n    // client[Width/Height] properties represent viewport area of the window.\n    // Besides, it's as well not necessary as the <html> itself neither has\n    // rendered scroll bars nor it can be clipped.\n    if (!isDocumentElement(target)) {\n        // In some browsers (only in Firefox, actually) CSS width & height\n        // include scroll bars size which can be removed at this step as scroll\n        // bars are the only difference between rounded dimensions + paddings\n        // and \"client\" properties, though that is not always true in Chrome.\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n\n        // Chrome has a rather weird rounding of \"client\" properties.\n        // E.g. for an element with content width of 314.2px it sometimes gives\n        // the client width of 315px and for the width of 314.7px it may give\n        // 314px. And it doesn't happen all the time. So just ignore this delta\n        // as a non-relevant.\n        if (Math.abs(vertScrollbar) !== 1) {\n            width -= vertScrollbar;\n        }\n\n        if (Math.abs(horizScrollbar) !== 1) {\n            height -= horizScrollbar;\n        }\n    }\n\n    return createRectInit(paddings.left, paddings.top, width, height);\n}\n\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nvar isSVGGraphicsElement = (function () {\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\n    // interface.\n    if (typeof SVGGraphicsElement !== 'undefined') {\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\n    }\n\n    // If it's so, then check that element is at least an instance of the\n    // SVGElement and that it has the \"getBBox\" method.\n    // eslint-disable-next-line no-extra-parens\n    return function (target) { return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function'; };\n})();\n\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nfunction isDocumentElement(target) {\n    return target === getWindowOf(target).document.documentElement;\n}\n\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getContentRect(target) {\n    if (!isBrowser) {\n        return emptyRect;\n    }\n\n    if (isSVGGraphicsElement(target)) {\n        return getSVGContentRect(target);\n    }\n\n    return getHTMLElementContentRect(target);\n}\n\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\nfunction createReadOnlyRect(ref) {\n    var x = ref.x;\n    var y = ref.y;\n    var width = ref.width;\n    var height = ref.height;\n\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\n    var rect = Object.create(Constr.prototype);\n\n    // Rectangle's properties are not writable and non-enumerable.\n    defineConfigurable(rect, {\n        x: x, y: y, width: width, height: height,\n        top: y,\n        right: x + width,\n        bottom: height + y,\n        left: x\n    });\n\n    return rect;\n}\n\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\nfunction createRectInit(x, y, width, height) {\n    return { x: x, y: y, width: width, height: height };\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\nvar ResizeObservation = function(target) {\n    this.broadcastWidth = 0;\n    this.broadcastHeight = 0;\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\n\n    this.target = target;\n};\n\n/**\r\n * Updates content rectangle and tells whether it's width or height properties\r\n * have changed since the last broadcast.\r\n *\r\n * @returns {boolean}\r\n */\n\n\n/**\r\n * Reference to the last observed content rectangle.\r\n *\r\n * @private {DOMRectInit}\r\n */\n\n\n/**\r\n * Broadcasted width of content rectangle.\r\n *\r\n * @type {number}\r\n */\nResizeObservation.prototype.isActive = function () {\n    var rect = getContentRect(this.target);\n\n    this.contentRect_ = rect;\n\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n};\n\n/**\r\n * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n * from the corresponding properties of the last observed content rectangle.\r\n *\r\n * @returns {DOMRectInit} Last observed content rectangle.\r\n */\nResizeObservation.prototype.broadcastRect = function () {\n    var rect = this.contentRect_;\n\n    this.broadcastWidth = rect.width;\n    this.broadcastHeight = rect.height;\n\n    return rect;\n};\n\nvar ResizeObserverEntry = function(target, rectInit) {\n    var contentRect = createReadOnlyRect(rectInit);\n\n    // According to the specification following properties are not writable\n    // and are also not enumerable in the native implementation.\n    //\n    // Property accessors are not being used as they'd require to define a\n    // private WeakMap storage which may cause memory leaks in browsers that\n    // don't support this type of collections.\n    defineConfigurable(this, { target: target, contentRect: contentRect });\n};\n\nvar ResizeObserverSPI = function(callback, controller, callbackCtx) {\n    this.activeObservations_ = [];\n    this.observations_ = new MapShim();\n\n    if (typeof callback !== 'function') {\n        throw new TypeError('The callback provided as parameter 1 is not a function.');\n    }\n\n    this.callback_ = callback;\n    this.controller_ = controller;\n    this.callbackCtx_ = callbackCtx;\n};\n\n/**\r\n * Starts observing provided element.\r\n *\r\n * @param {Element} target - Element to be observed.\r\n * @returns {void}\r\n */\n\n\n/**\r\n * Registry of the ResizeObservation instances.\r\n *\r\n * @private {Map<Element, ResizeObservation>}\r\n */\n\n\n/**\r\n * Public ResizeObserver instance which will be passed to the callback\r\n * function and used as a value of it's \"this\" binding.\r\n *\r\n * @private {ResizeObserver}\r\n */\n\n/**\r\n * Collection of resize observations that have detected changes in dimensions\r\n * of elements.\r\n *\r\n * @private {Array<ResizeObservation>}\r\n */\nResizeObserverSPI.prototype.observe = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is already being observed.\n    if (observations.has(target)) {\n        return;\n    }\n\n    observations.set(target, new ResizeObservation(target));\n\n    this.controller_.addObserver(this);\n\n    // Force the update of observations.\n    this.controller_.refresh();\n};\n\n/**\r\n * Stops observing provided element.\r\n *\r\n * @param {Element} target - Element to stop observing.\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.unobserve = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is not being observed.\n    if (!observations.has(target)) {\n        return;\n    }\n\n    observations.delete(target);\n\n    if (!observations.size) {\n        this.controller_.removeObserver(this);\n    }\n};\n\n/**\r\n * Stops observing all elements.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.disconnect = function () {\n    this.clearActive();\n    this.observations_.clear();\n    this.controller_.removeObserver(this);\n};\n\n/**\r\n * Collects observation instances the associated element of which has changed\r\n * it's content rectangle.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.gatherActive = function () {\n        var this$1 = this;\n\n    this.clearActive();\n\n    this.observations_.forEach(function (observation) {\n        if (observation.isActive()) {\n            this$1.activeObservations_.push(observation);\n        }\n    });\n};\n\n/**\r\n * Invokes initial callback function with a list of ResizeObserverEntry\r\n * instances collected from active resize observations.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.broadcastActive = function () {\n    // Do nothing if observer doesn't have active observations.\n    if (!this.hasActive()) {\n        return;\n    }\n\n    var ctx = this.callbackCtx_;\n\n    // Create ResizeObserverEntry instance for every active observation.\n    var entries = this.activeObservations_.map(function (observation) {\n        return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n    });\n\n    this.callback_.call(ctx, entries, ctx);\n    this.clearActive();\n};\n\n/**\r\n * Clears the collection of active observations.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.clearActive = function () {\n    this.activeObservations_.splice(0);\n};\n\n/**\r\n * Tells whether observer has active observations.\r\n *\r\n * @returns {boolean}\r\n */\nResizeObserverSPI.prototype.hasActive = function () {\n    return this.activeObservations_.length > 0;\n};\n\n// Registry of internal observers. If WeakMap is not available use current shim\n// for the Map collection as it has all required methods and because WeakMap\n// can't be fully polyfilled anyway.\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\n\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\nvar ResizeObserver = function(callback) {\n    if (!(this instanceof ResizeObserver)) {\n        throw new TypeError('Cannot call a class as a function.');\n    }\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    var controller = ResizeObserverController.getInstance();\n    var observer = new ResizeObserverSPI(callback, controller, this);\n\n    observers.set(this, observer);\n};\n\n// Expose public methods of ResizeObserver.\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\n    ResizeObserver.prototype[method] = function () {\n        return (ref = observers.get(this))[method].apply(ref, arguments);\n        var ref;\n    };\n});\n\nvar index = (function () {\n    // Export existing implementation if available.\n    if (typeof global$1.ResizeObserver !== 'undefined') {\n        return global$1.ResizeObserver;\n    }\n\n    return ResizeObserver;\n})();\n\nexport default index;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n// module id = 5\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}