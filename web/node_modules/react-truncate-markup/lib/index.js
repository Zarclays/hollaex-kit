'use strict';

exports.__esModule = true;
exports.default = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp2;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lineHeight = require('line-height');

var _lineHeight2 = _interopRequireDefault(_lineHeight);

var _resizeObserverPolyfill = require('resize-observer-polyfill');

var _resizeObserverPolyfill2 = _interopRequireDefault(_resizeObserverPolyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SPLIT = {
  LEFT: true,
  RIGHT: false
};

var toString = function toString(node) {
  var string = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  if (!node) {
    return string;
  } else if (typeof node === 'string') {
    return string + node;
  } else if (Array.isArray(node)) {
    var newString = string;
    node.forEach(function (child) {
      newString = toString(child, newString);
    });

    return newString;
  }

  return toString(node.props.children, string);
};

var cloneWithChildren = function cloneWithChildren(node, children, isRootEl, level) {
  return _extends({}, node, {
    props: _extends({}, node.props, {
      style: _extends({}, node.props.style, isRootEl ? {
        // root element cannot be an inline element because of the line calculation
        display: (node.props.style || {}).display || 'block'
      } : level === 2 ? {
        // level 2 elements (direct children of the root element) need to be inline because of the ellipsis.
        // if level 2 element was a block element, ellipsis would get rendered on a new line, breaking the max number of lines
        display: (node.props.style || {}).display || 'inline-block'
      } : {}),
      children: children
    })
  });
};

var validateTree = function validateTree(node) {
  if (typeof node === 'string') {
    return true;
  } else if (typeof node.type === 'function') {
    if (process.env.NODE_ENV !== 'production') {
      /* eslint-disable no-console */
      console.error('ReactTruncateMarkup tried to render <' + node.type.name + ' />, but truncating React components is not supported, the full content is rendered instead. Only DOM elements are supported.');
      /* eslint-enable */
    }

    return false;
  }

  if (node.props.children) {
    if (Array.isArray(node.props.children)) {
      return node.props.children.reduce(function (isValid, child) {
        return isValid && validateTree(child);
      }, true);
    }

    return validateTree(node.props.children);
  }

  return true;
};

var TruncateMarkup = (_temp2 = _class = function (_React$Component) {
  _inherits(TruncateMarkup, _React$Component);

  function TruncateMarkup() {
    var _temp, _this, _ret;

    _classCallCheck(this, TruncateMarkup);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      text: _this.childrenElementWithRef(_this.props.children)
    }, _this.isValid = validateTree(_this.props.children), _this.lineHeight = null, _this.splitDirectionSeq = [], _this.shouldTruncate = true, _this.wasLastCharTested = false, _this.endFound = false, _this.latestThatFits = null, _this.origText = null, _this.clientWidth = null, _this.onAfterTruncateCalled = false, _this.onAfterTruncate = function (wasTruncated) {
      if (!_this.onAfterTruncateCalled) {
        _this.onAfterTruncateCalled = true;
        _this.props.onAfterTruncate(wasTruncated);
      }
    }, _this.handleResize = function () {
      /* Wrapper element resize handing */
      var initialRender = true;

      _this.resizeObserver = new _resizeObserverPolyfill2.default(function () {
        if (initialRender) {
          // ResizeObserer cb is called on initial render too so we are skipping here
          initialRender = false;
        } else {
          // wrapper element has been resized, recalculating with the original text
          _this.shouldTruncate = false;
          _this.latestThatFits = null;

          _this.setState({
            text: _this.origText
          }, function () {
            _this.shouldTruncate = true;
            _this.onAfterTruncateCalled = false;
            _this.truncate();
          });
        }
      });

      _this.resizeObserver.observe(_this.el);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  TruncateMarkup.prototype.componentDidMount = function componentDidMount() {
    if (!this.isValid) {
      return;
    }

    this.origText = this.state.text;

    // get the computed line-height of the parent element
    // it'll be used for determining whether the text fits the container or not
    this.lineHeight = this.props.lineHeight || (0, _lineHeight2.default)(this.el);

    this.truncate();

    this.handleResize();
  };

  TruncateMarkup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }

    this.shouldTruncate = false;
    this.latestThatFits = null;
    this.isValid = validateTree(nextProps.children);

    this.setState({
      text: this.childrenElementWithRef(nextProps.children)
    }, function () {
      if (!_this2.isValid) {
        return;
      }

      _this2.origText = _this2.state.text;
      _this2.lineHeight = nextProps.lineHeight || (0, _lineHeight2.default)(_this2.el);
      _this2.shouldTruncate = true;
      _this2.truncate();

      _this2.handleResize();
    });
  };

  TruncateMarkup.prototype.componentDidUpdate = function componentDidUpdate() {
    if (this.shouldTruncate === false || this.isValid === false) {
      return;
    }

    if (this.endFound) {
      // we've found the end where we cannot split the text further
      // that means we've already found the max subtree that fits the container
      // so we are rendering that
      if (this.state.text !== this.latestThatFits) {
        /* eslint-disable react/no-did-update-set-state */
        this.setState({
          text: this.latestThatFits
        });

        return;
        /* eslint-enable */
      } else if (this.el && this.el.clientWidth !== this.clientWidth) {
        // edge case - scrollbar (dis?)appearing might mess up the container width
        // causing strings that would normally fit on X lines to suddenly take up X+1 lines
        // ugly fix - recalculate again
        this.truncateOriginalText();

        return;
      }

      this.onAfterTruncate( /* wasTruncated */true);

      return;
    }

    if (this.splitDirectionSeq.length) {
      if (this.fits()) {
        this.latestThatFits = this.state.text;
        this.clientWidth = this.el.clientWidth;
        // we've found a subtree that fits the container
        // but we need to check if we didn't cut too much of it off
        // so we are changing the last splitting decision from splitting and going left
        // to splitting and going right
        this.splitDirectionSeq.splice(this.splitDirectionSeq.length - 1, 1, SPLIT.RIGHT, SPLIT.LEFT);
      } else {
        this.splitDirectionSeq.push(SPLIT.LEFT);
      }

      this.tryToFit(this.origText, this.splitDirectionSeq);
    }
  };

  TruncateMarkup.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }

    this.lineHeight = null;
    this.origText = null;
    this.latestThatFits = null;
    this.splitDirectionSeq = [];
  };

  TruncateMarkup.prototype.truncate = function truncate() {
    if (this.fits()) {
      // the whole text fits on the first try, no need to do anything else
      this.shouldTruncate = false;
      this.onAfterTruncate( /* wasTruncated */false);

      return;
    }

    this.truncateOriginalText();
  };

  TruncateMarkup.prototype.childrenElementWithRef = function childrenElementWithRef(children) {
    var _this3 = this;

    var child = _react2.default.Children.only(children);

    return _react2.default.cloneElement(child, { ref: function ref(el) {
        return _this3.el = el;
      } });
  };

  TruncateMarkup.prototype.truncateOriginalText = function truncateOriginalText() {
    this.endFound = false;
    this.splitDirectionSeq = [SPLIT.LEFT];
    this.wasLastCharTested = false;

    this.tryToFit(this.origText, this.splitDirectionSeq);
  };

  /**
   * Splits rootEl based on instructions and updates React's state with the returned element
   * After React rerenders the new text, we'll check if the new text fits in componentDidUpdate
   * @param  {ReactElement} rootEl - the original children element
   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions
   */


  TruncateMarkup.prototype.tryToFit = function tryToFit(rootEl, splitDirections) {
    if (!rootEl.props.children) {
      // no markup in container
      return;
    }

    var newRootEl = this.split(rootEl, splitDirections, /* isRootEl */true);

    var ellipsis = typeof this.props.ellipsis === 'function' ? this.props.ellipsis(newRootEl) : this.props.ellipsis;

    ellipsis = (typeof ellipsis === 'undefined' ? 'undefined' : _typeof(ellipsis)) === 'object' ? _react2.default.cloneElement(ellipsis, { key: 'ellipsis' }) : ellipsis;

    var newChildren = newRootEl.props.children;
    var newChildrenWithEllipsis = Array.isArray(newChildren) ? [].concat(newChildren, [ellipsis]) : [newChildren, ellipsis];

    // edge case tradeoff EC#1 - on initial render it doesn't fit in the requested number of lines (1) so it starts truncating
    // - because of truncating and the ellipsis position, div#lvl2 will have display set to 'inline-block',
    //   causing the whole body to fit in 1 line again
    // - if that happens, ellipsis is not needed anymore as the whole body is rendered
    // - NOTE this could be fixed by checking for this exact case and handling it separately so it renders <div>foo {ellipsis}</div>
    //
    // Example:
    // <TruncateMarkup lines={1}>
    //   <div>
    //     foo
    //     <div id="lvl2">bar</div>
    //   </div>
    // </TruncateMarkup>
    var shouldRenderEllipsis = toString(newChildren) !== toString(this.origText);

    this.setState({
      text: _extends({}, newRootEl, {
        props: _extends({}, newRootEl.props, {
          style: _extends({
            wordWrap: 'break-word'
          }, newRootEl.props.style),
          children: shouldRenderEllipsis ? newChildrenWithEllipsis : newChildren
        })
      })
    });
  };

  /**
   * Splits JSX node based on its type
   * @param  {null|string|Array|Object} node - JSX node
   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions
   * @return {null|string|Array|Object} - split JSX node
   */


  TruncateMarkup.prototype.split = function split(node, splitDirections) {
    var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    if (!node) {
      return node;
    } else if (typeof node === 'string') {
      return this.splitString(node, splitDirections);
    } else if (Array.isArray(node)) {
      return this.splitArray(node, splitDirections, level);
    }

    var newChildren = this.split(node.props.children, splitDirections,
    /* isRoot */false, level + 1);

    return cloneWithChildren(node, newChildren, isRoot, level);
  };

  TruncateMarkup.prototype.splitString = function splitString(string) {
    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (!splitDirections.length) {
      return string;
    }

    if (splitDirections.length && string.length === 1) {
      // allow for an extra render test with the current character included
      // in most cases this variation was already tested, but some edge cases require this check
      // NOTE could be removed once EC#1 is taken care of
      if (!this.wasLastCharTested) {
        this.wasLastCharTested = true;
      } else {
        // we are trying to split further but we have nowhere to go now
        // that means we've already found the max subtree that fits the container
        this.endFound = true;
      }

      return string;
    }

    var splitDirection = splitDirections[0],
        restSplitDirections = splitDirections.slice(1);

    var pivotIndex = Math.ceil(string.length / 2);

    if (splitDirection === SPLIT.LEFT) {
      var subString = string.substring(0, pivotIndex);

      return this.splitString(subString, restSplitDirections);
    }
    var beforeString = string.substring(0, pivotIndex);
    var afterString = string.substring(pivotIndex);

    return beforeString + this.splitString(afterString, restSplitDirections);
  };

  TruncateMarkup.prototype.splitArray = function splitArray(array) {
    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var level = arguments[2];

    if (!splitDirections.length) {
      return array;
    }

    if (array.length === 1) {
      var item = array[0];


      if (typeof item === 'string') {
        return [this.splitString(item, splitDirections)];
      }
      var children = item.props.children;


      var newChildren = this.split(children, splitDirections,
      /* isRoot */false, level + 1);

      return [cloneWithChildren(item, newChildren, /* isRoot */false, level)];
    }

    var splitDirection = splitDirections[0],
        restSplitDirections = splitDirections.slice(1);

    var pivotIndex = Math.ceil(array.length / 2);

    if (splitDirection === SPLIT.LEFT) {
      var subArray = array.slice(0, pivotIndex);

      return this.splitArray(subArray, restSplitDirections, level);
    }
    var beforeArray = array.slice(0, pivotIndex);
    var afterArray = array.slice(pivotIndex);

    return beforeArray.concat(this.splitArray(afterArray, restSplitDirections, level));
  };

  TruncateMarkup.prototype.fits = function fits() {
    var maxLines = this.props.lines;

    var _el$getBoundingClient = this.el.getBoundingClientRect(),
        height = _el$getBoundingClient.height;

    var computedLines = Math.round(height / parseFloat(this.lineHeight));

    if (process.env.NODE_ENV !== 'production' && computedLines <= 0) {
      /* eslint-disable no-console */
      console.warn('ReactTruncateMarkup: number of currently rendered lines: ' + computedLines + ', not truncating...\n  It may be caused by target element not being visible at the time of computation.');
      /* eslint-enable */
    }

    return maxLines >= computedLines;
  };

  TruncateMarkup.prototype.render = function render() {
    return this.state.text;
  };

  return TruncateMarkup;
}(_react2.default.Component), _class.defaultProps = {
  lines: 1,
  ellipsis: '...',
  lineHeight: '',
  onAfterTruncate: function onAfterTruncate() {}
}, _temp2);
exports.default = TruncateMarkup;
TruncateMarkup.propTypes = process.env.NODE_ENV !== "production" ? {
  children: _propTypes2.default.element.isRequired,
  lines: _propTypes2.default.number,
  ellipsis: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.string, _propTypes2.default.func]),
  lineHeight: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
  onAfterTruncate: _propTypes2.default.func
} : {};
module.exports = exports['default'];