{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _utils = require('./utils');\n\nvar utils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Simple module to localize the React interface using the same syntax\n * used in the ReactNativeLocalization module\n * (https://github.com/stefalda/ReactNativeLocalization)\n *\n * Originally developed by Stefano Falda (stefano.falda@gmail.com)\n *\n * It uses a call to the Navigator/Browser object to get the current interface language,\n * then display the correct language strings or the default language (the first\n * one if a match is not found).\n *\n * How to use:\n * Check the instructions at:\n * https://github.com/stefalda/react-localization\n */\n\n\nvar placeholderRegex = /(\\{[\\d|\\w]+\\})/;\n\nvar isReactComponent = function isReactComponent(value) {\n  return _typeof(value.$$typeof) === 'symbol';\n};\n\nvar LocalizedStrings = function () {\n  _createClass(LocalizedStrings, [{\n    key: '_getBestMatchingLanguage',\n    value: function _getBestMatchingLanguage(language, props) {\n      //If an object with the passed language key exists return it\n      if (props[language]) return language; //if the string is composed try to find a match with only the first language identifiers (en-US --> en)\n\n      var idx = language.indexOf('-');\n      var auxLang = idx >= 0 ? language.substring(0, idx) : language;\n      return props[auxLang] ? auxLang : Object.keys(props)[0];\n    }\n  }]);\n\n  function LocalizedStrings(props) {\n    _classCallCheck(this, LocalizedStrings);\n\n    this._interfaceLanguage = utils.getInterfaceLanguage();\n    this._language = this._interfaceLanguage;\n    this.setContent(props);\n  }\n\n  _createClass(LocalizedStrings, [{\n    key: 'setContent',\n    value: function setContent(props) {\n      this._defaultLanguage = Object.keys(props)[0];\n      this._defaultLanguageFirstLevelKeys = []; //Store locally the passed strings\n\n      this._props = props;\n      utils.validateTranslationKeys(Object.keys(props[this._defaultLanguage])); //Store first level keys (for identifying missing translations)\n\n      for (var key in this._props[this._defaultLanguage]) {\n        if (typeof this._props[this._defaultLanguage][key] == \"string\") {\n          this._defaultLanguageFirstLevelKeys.push(key);\n        }\n      } //Set language to its default value (the interface)\n\n\n      this.setLanguage(this._interfaceLanguage);\n    } //Can be used from ouside the class to force a particular language\n    //indipendently from the interface one\n\n  }, {\n    key: 'setLanguage',\n    value: function setLanguage(language) {\n      //Check if exists a translation for the current language or if the default\n      //should be used\n      var bestLanguage = this._getBestMatchingLanguage(language, this._props);\n\n      var defaultLanguage = Object.keys(this._props)[0];\n      this._language = bestLanguage; //Associate the language object to the this object\n\n      if (this._props[bestLanguage]) {\n        //delete default propery values to identify missing translations\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this._defaultLanguageFirstLevelKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            key = _step.value;\n            delete this[key];\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        var localizedStrings = Object.assign({}, this._props[this._language]);\n\n        for (var key in localizedStrings) {\n          if (localizedStrings.hasOwnProperty(key)) {\n            this[key] = localizedStrings[key];\n          }\n        } //Now add any string missing from the translation but existing in the default language\n\n\n        if (defaultLanguage !== this._language) {\n          localizedStrings = this._props[defaultLanguage];\n\n          this._fallbackValues(localizedStrings, this);\n        }\n      }\n    } //Load fallback values for missing translations\n\n  }, {\n    key: '_fallbackValues',\n    value: function _fallbackValues(defaultStrings, strings) {\n      for (var key in defaultStrings) {\n        if (defaultStrings.hasOwnProperty(key) && !strings[key]) {\n          strings[key] = defaultStrings[key];\n          console.log(\"\\uD83D\\uDEA7 \\uD83D\\uDC77 key '\" + key + '\\' not found in localizedStrings for language ' + this._language + \" \\uD83D\\uDEA7\");\n        } else {\n          if (typeof strings[key] != \"string\") {\n            //It's an object\n            this._fallbackValues(defaultStrings[key], strings[key]);\n          }\n        }\n      }\n    } //The current language displayed (could differ from the interface language\n    // if it has been forced manually and a matching translation has been found)\n\n  }, {\n    key: 'getLanguage',\n    value: function getLanguage() {\n      return this._language;\n    } //The current interface language (could differ from the language displayed)\n\n  }, {\n    key: 'getInterfaceLanguage',\n    value: function getInterfaceLanguage() {\n      return this._interfaceLanguage;\n    } //Return an array containing the available languages passed as props in the constructor\n\n  }, {\n    key: 'getAvailableLanguages',\n    value: function getAvailableLanguages() {\n      if (!this._availableLanguages) {\n        this._availableLanguages = [];\n\n        for (var language in this._props) {\n          this._availableLanguages.push(language);\n        }\n      }\n\n      return this._availableLanguages;\n    } //Format the passed string replacing the numbered or tokenized placeholders\n    //eg. 1: I'd like some {0} and {1}, or just {0}\n    //eg. 2: I'd like some {bread} and {butter}, or just {bread}\n    //Use example:\n    //eg. 1: strings.formatString(strings.question, strings.bread, strings.butter)\n    //eg. 2: strings.formatString(strings.question, { bread: strings.bread, butter: strings.butter })\n\n  }, {\n    key: 'formatString',\n    value: function formatString(str) {\n      for (var _len = arguments.length, valuesForPlaceholders = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        valuesForPlaceholders[_key - 1] = arguments[_key];\n      }\n\n      return str.split(placeholderRegex).filter(function (textPart) {\n        return !!textPart;\n      }).map(function (textPart, index) {\n        if (textPart.match(placeholderRegex)) {\n          var matchedKey = textPart.slice(1, -1);\n          var valueForPlaceholder = valuesForPlaceholders[matchedKey]; // If no value found, check if working with an object instead\n\n          if (valueForPlaceholder == undefined) {\n            var valueFromObjectPlaceholder = valuesForPlaceholders[0][matchedKey];\n\n            if (valueFromObjectPlaceholder !== undefined) {\n              valueForPlaceholder = valueFromObjectPlaceholder;\n            } else {\n              // If value still isn't found, then it must have been undefined/null\n              return valueForPlaceholder;\n            }\n          }\n\n          if (isReactComponent(valueForPlaceholder)) {\n            return _react2.default.Children.toArray(valueForPlaceholder).map(function (component) {\n              return _extends({}, component, {\n                key: index.toString()\n              });\n            });\n          }\n\n          return valueForPlaceholder;\n        }\n\n        return textPart;\n      });\n    } //Return a string with the passed key in a different language\n\n  }, {\n    key: 'getString',\n    value: function getString(key, language) {\n      try {\n        return this._props[language][key];\n      } catch (ex) {\n        console.log(\"No localization found for key \" + key + \" and language \" + language);\n      }\n\n      return null;\n    }\n  }]);\n\n  return LocalizedStrings;\n}();\n\nexports.default = LocalizedStrings;","map":null,"metadata":{},"sourceType":"script"}