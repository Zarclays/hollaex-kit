{"ast":null,"code":"/*!\n * numbro.js\n * version : 1.11.1\n * author : FÃ¶retagsplatsen AB\n * license : MIT\n * http://www.foretagsplatsen.se\n */\n(function () {\n  'use strict';\n  /************************************\n      Constants\n  ************************************/\n\n  var _numbro,\n      VERSION = '1.11.1',\n      binarySuffixes = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'],\n      decimalSuffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],\n      bytes = {\n    general: {\n      scale: 1024,\n      suffixes: decimalSuffixes,\n      marker: 'bd'\n    },\n    binary: {\n      scale: 1024,\n      suffixes: binarySuffixes,\n      marker: 'b'\n    },\n    decimal: {\n      scale: 1000,\n      suffixes: decimalSuffixes,\n      marker: 'd'\n    }\n  },\n      // general must be before the others because it reuses their characters!\n  byteFormatOrder = [bytes.general, bytes.binary, bytes.decimal],\n      // internal storage for culture config files\n  cultures = {},\n      // Todo: Remove in 2.0.0\n  languages = cultures,\n      currentCulture = 'en-US',\n      zeroFormat = null,\n      defaultFormat = '0,0',\n      defaultCurrencyFormat = '0$',\n      // check for nodeJS\n  hasModule = typeof module !== 'undefined' && module.exports,\n      // default culture\n  enUS = {\n    delimiters: {\n      thousands: ',',\n      decimal: '.'\n    },\n    abbreviations: {\n      thousand: 'k',\n      million: 'm',\n      billion: 'b',\n      trillion: 't'\n    },\n    ordinal: function ordinal(number) {\n      var b = number % 10;\n      return ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';\n    },\n    currency: {\n      symbol: '$',\n      position: 'prefix'\n    },\n    defaults: {\n      currencyFormat: ',0000 a'\n    },\n    formats: {\n      fourDigits: '0000 a',\n      fullWithTwoDecimals: '$ ,0.00',\n      fullWithTwoDecimalsNoCurrency: ',0.00'\n    }\n  };\n  /************************************\n      Constructors\n  ************************************/\n  // Numbro prototype object\n\n\n  function Numbro(number) {\n    this._value = number;\n  }\n\n  function numberLength(number) {\n    if (number === 0) {\n      return 1;\n    }\n\n    return Math.floor(Math.log(Math.abs(number)) / Math.LN10) + 1;\n  }\n\n  function zeroes(count) {\n    var i,\n        ret = '';\n\n    for (i = 0; i < count; i++) {\n      ret += '0';\n    }\n\n    return ret;\n  }\n  /**\n   * Implementation of toFixed() for numbers with exponents\n   * This function may return negative representations for zero values e.g. \"-0.0\"\n   */\n\n\n  function toFixedLargeSmall(value, precision) {\n    var mantissa, beforeDec, afterDec, exponent, prefix, endStr, zerosStr, str;\n    str = value.toString();\n    mantissa = str.split('e')[0];\n    exponent = str.split('e')[1];\n    beforeDec = mantissa.split('.')[0];\n    afterDec = mantissa.split('.')[1] || '';\n\n    if (+exponent > 0) {\n      // exponent is positive - add zeros after the numbers\n      str = beforeDec + afterDec + zeroes(exponent - afterDec.length);\n    } else {\n      // exponent is negative\n      if (+beforeDec < 0) {\n        prefix = '-0';\n      } else {\n        prefix = '0';\n      } // tack on the decimal point if needed\n\n\n      if (precision > 0) {\n        prefix += '.';\n      }\n\n      zerosStr = zeroes(-1 * exponent - 1); // substring off the end to satisfy the precision\n\n      endStr = (zerosStr + Math.abs(beforeDec) + afterDec).substr(0, precision);\n      str = prefix + endStr;\n    } // only add percision 0's if the exponent is positive\n\n\n    if (+exponent > 0 && precision > 0) {\n      str += '.' + zeroes(precision);\n    }\n\n    return str;\n  }\n  /**\n   * Implementation of toFixed() that treats floats more like decimals\n   *\n   * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n   * problems for accounting- and finance-related software.\n   *\n   * Also removes negative signs for zero-formatted numbers. e.g. -0.01 w/ precision 1 -> 0.0\n   */\n\n\n  function toFixed(value, precision, roundingFunction, optionals) {\n    var power = Math.pow(10, precision),\n        optionalsRegExp,\n        output;\n\n    if (value.toString().indexOf('e') > -1) {\n      // toFixed returns scientific notation for numbers above 1e21 and below 1e-7\n      output = toFixedLargeSmall(value, precision); // remove the leading negative sign if it exists and should not be present (e.g. -0.00)\n\n      if (output.charAt(0) === '-' && +output >= 0) {\n        output = output.substr(1); // chop off the '-'\n      }\n    } else {\n      // Multiply up by precision, round accurately, then divide and use native toFixed():\n      output = (roundingFunction(value + 'e+' + precision) / power).toFixed(precision);\n    }\n\n    if (optionals) {\n      optionalsRegExp = new RegExp('0{1,' + optionals + '}$');\n      output = output.replace(optionalsRegExp, '');\n    }\n\n    return output;\n  }\n  /************************************\n      Formatting\n  ************************************/\n  // determine what type of formatting we need to do\n\n\n  function formatNumbro(n, format, roundingFunction) {\n    var output,\n        escapedFormat = format.replace(/\\{[^\\{\\}]*\\}/g, ''); // figure out what kind of format we are dealing with\n\n    if (escapedFormat.indexOf('$') > -1) {\n      // currency!!!!!\n      output = _formatCurrency(n, cultures[currentCulture].currency.symbol, format, roundingFunction);\n    } else if (escapedFormat.indexOf('%') > -1) {\n      // percentage\n      output = formatPercentage(n, format, roundingFunction);\n    } else if (escapedFormat.indexOf(':') > -1) {\n      // time\n      output = formatTime(n, format);\n    } else {\n      // plain ol' numbers or bytes\n      output = formatNumber(n._value, format, roundingFunction);\n    } // return string\n\n\n    return output;\n  } // revert to number\n\n\n  function unformatNumbro(n, string) {\n    var stringOriginal = string,\n        thousandRegExp,\n        millionRegExp,\n        billionRegExp,\n        trillionRegExp,\n        bytesMultiplier = false,\n        power;\n\n    if (string.indexOf(':') > -1) {\n      n._value = unformatTime(string);\n    } else {\n      if (string === zeroFormat) {\n        n._value = 0;\n      } else {\n        if (cultures[currentCulture].delimiters.decimal !== '.') {\n          string = string.replace(/\\./g, '').replace(cultures[currentCulture].delimiters.decimal, '.');\n        } // see if abbreviations are there so that we can multiply to the correct number\n\n\n        thousandRegExp = new RegExp('[^a-zA-Z]' + cultures[currentCulture].abbreviations.thousand + '(?:\\\\)|(\\\\' + cultures[currentCulture].currency.symbol + ')?(?:\\\\))?)?$');\n        millionRegExp = new RegExp('[^a-zA-Z]' + cultures[currentCulture].abbreviations.million + '(?:\\\\)|(\\\\' + cultures[currentCulture].currency.symbol + ')?(?:\\\\))?)?$');\n        billionRegExp = new RegExp('[^a-zA-Z]' + cultures[currentCulture].abbreviations.billion + '(?:\\\\)|(\\\\' + cultures[currentCulture].currency.symbol + ')?(?:\\\\))?)?$');\n        trillionRegExp = new RegExp('[^a-zA-Z]' + cultures[currentCulture].abbreviations.trillion + '(?:\\\\)|(\\\\' + cultures[currentCulture].currency.symbol + ')?(?:\\\\))?)?$'); // see if bytes are there so that we can multiply to the correct number\n\n        for (power = 1; power < binarySuffixes.length && !bytesMultiplier; ++power) {\n          if (string.indexOf(binarySuffixes[power]) > -1) {\n            bytesMultiplier = Math.pow(1024, power);\n          } else if (string.indexOf(decimalSuffixes[power]) > -1) {\n            bytesMultiplier = Math.pow(1000, power);\n          }\n        }\n\n        var str = string.replace(/[^0-9\\.]+/g, '');\n\n        if (str === '') {\n          // An empty string is not a number.\n          n._value = NaN;\n        } else {\n          // do some math to create our number\n          n._value = (bytesMultiplier ? bytesMultiplier : 1) * (stringOriginal.match(thousandRegExp) ? Math.pow(10, 3) : 1) * (stringOriginal.match(millionRegExp) ? Math.pow(10, 6) : 1) * (stringOriginal.match(billionRegExp) ? Math.pow(10, 9) : 1) * (stringOriginal.match(trillionRegExp) ? Math.pow(10, 12) : 1) * (string.indexOf('%') > -1 ? 0.01 : 1) * ((string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1) * Number(str); // round if we are talking about bytes\n\n          n._value = bytesMultiplier ? Math.ceil(n._value) : n._value;\n        }\n      }\n    }\n\n    return n._value;\n  }\n\n  function _formatCurrency(n, currencySymbol, originalFormat, roundingFunction) {\n    var format = originalFormat,\n        symbolIndex = format.indexOf('$'),\n        openParenIndex = format.indexOf('('),\n        plusSignIndex = format.indexOf('+'),\n        minusSignIndex = format.indexOf('-'),\n        space = '',\n        decimalSeparator = '',\n        spliceIndex,\n        output;\n\n    if (format.indexOf('$') === -1) {\n      // Use defaults instead of the format provided\n      if (cultures[currentCulture].currency.position === 'infix') {\n        decimalSeparator = currencySymbol;\n\n        if (cultures[currentCulture].currency.spaceSeparated) {\n          decimalSeparator = ' ' + decimalSeparator + ' ';\n        }\n      } else if (cultures[currentCulture].currency.spaceSeparated) {\n        space = ' ';\n      }\n    } else {\n      // check for space before or after currency\n      if (format.indexOf(' $') > -1) {\n        space = ' ';\n        format = format.replace(' $', '');\n      } else if (format.indexOf('$ ') > -1) {\n        space = ' ';\n        format = format.replace('$ ', '');\n      } else {\n        format = format.replace('$', '');\n      }\n    } // Format The Number\n\n\n    output = formatNumber(n._value, format, roundingFunction, decimalSeparator);\n\n    if (originalFormat.indexOf('$') === -1) {\n      // Use defaults instead of the format provided\n      switch (cultures[currentCulture].currency.position) {\n        case 'postfix':\n          if (output.indexOf(')') > -1) {\n            output = output.split('');\n            output.splice(-1, 0, space + currencySymbol);\n            output = output.join('');\n          } else {\n            output = output + space + currencySymbol;\n          }\n\n          break;\n\n        case 'infix':\n          break;\n\n        case 'prefix':\n          if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {\n            output = output.split('');\n            spliceIndex = Math.max(openParenIndex, minusSignIndex) + 1;\n            output.splice(spliceIndex, 0, currencySymbol + space);\n            output = output.join('');\n          } else {\n            output = currencySymbol + space + output;\n          }\n\n          break;\n\n        default:\n          throw Error('Currency position should be among [\"prefix\", \"infix\", \"postfix\"]');\n      }\n    } else {\n      // position the symbol\n      if (symbolIndex <= 1) {\n        if (output.indexOf('(') > -1 || output.indexOf('+') > -1 || output.indexOf('-') > -1) {\n          output = output.split('');\n          spliceIndex = 1;\n\n          if (symbolIndex < openParenIndex || symbolIndex < plusSignIndex || symbolIndex < minusSignIndex) {\n            // the symbol appears before the \"(\", \"+\" or \"-\"\n            spliceIndex = 0;\n          }\n\n          output.splice(spliceIndex, 0, currencySymbol + space);\n          output = output.join('');\n        } else {\n          output = currencySymbol + space + output;\n        }\n      } else {\n        if (output.indexOf(')') > -1) {\n          output = output.split('');\n          output.splice(-1, 0, space + currencySymbol);\n          output = output.join('');\n        } else {\n          output = output + space + currencySymbol;\n        }\n      }\n    }\n\n    return output;\n  }\n\n  function _formatForeignCurrency(n, foreignCurrencySymbol, originalFormat, roundingFunction) {\n    return _formatCurrency(n, foreignCurrencySymbol, originalFormat, roundingFunction);\n  }\n\n  function formatPercentage(n, format, roundingFunction) {\n    var space = '',\n        output,\n        value = n._value * 100; // check for space before %\n\n    if (format.indexOf(' %') > -1) {\n      space = ' ';\n      format = format.replace(' %', '');\n    } else {\n      format = format.replace('%', '');\n    }\n\n    output = formatNumber(value, format, roundingFunction);\n\n    if (output.indexOf(')') > -1) {\n      output = output.split('');\n      output.splice(-1, 0, space + '%');\n      output = output.join('');\n    } else {\n      output = output + space + '%';\n    }\n\n    return output;\n  }\n\n  function formatTime(n) {\n    var hours = Math.floor(n._value / 60 / 60),\n        minutes = Math.floor((n._value - hours * 60 * 60) / 60),\n        seconds = Math.round(n._value - hours * 60 * 60 - minutes * 60);\n    return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);\n  }\n\n  function unformatTime(string) {\n    var timeArray = string.split(':'),\n        seconds = 0; // turn hours and minutes into seconds and add them all up\n\n    if (timeArray.length === 3) {\n      // hours\n      seconds = seconds + Number(timeArray[0]) * 60 * 60; // minutes\n\n      seconds = seconds + Number(timeArray[1]) * 60; // seconds\n\n      seconds = seconds + Number(timeArray[2]);\n    } else if (timeArray.length === 2) {\n      // minutes\n      seconds = seconds + Number(timeArray[0]) * 60; // seconds\n\n      seconds = seconds + Number(timeArray[1]);\n    }\n\n    return Number(seconds);\n  }\n\n  function formatByteUnits(value, suffixes, scale) {\n    var suffix = suffixes[0],\n        power,\n        min,\n        max,\n        abs = Math.abs(value);\n\n    if (abs >= scale) {\n      for (power = 1; power < suffixes.length; ++power) {\n        min = Math.pow(scale, power);\n        max = Math.pow(scale, power + 1);\n\n        if (abs >= min && abs < max) {\n          suffix = suffixes[power];\n          value = value / min;\n          break;\n        }\n      } // values greater than or equal to [scale] YB never set the suffix\n\n\n      if (suffix === suffixes[0]) {\n        value = value / Math.pow(scale, suffixes.length - 1);\n        suffix = suffixes[suffixes.length - 1];\n      }\n    }\n\n    return {\n      value: value,\n      suffix: suffix\n    };\n  }\n\n  function formatNumber(value, format, roundingFunction, sep) {\n    var negP = false,\n        signed = false,\n        optDec = false,\n        abbr = '',\n        abbrK = false,\n        // force abbreviation to thousands\n    abbrM = false,\n        // force abbreviation to millions\n    abbrB = false,\n        // force abbreviation to billions\n    abbrT = false,\n        // force abbreviation to trillions\n    abbrForce = false,\n        // force abbreviation\n    bytes = '',\n        byteFormat,\n        units,\n        ord = '',\n        abs = Math.abs(value),\n        totalLength,\n        length,\n        minimumPrecision,\n        pow,\n        w,\n        intPrecision,\n        precision,\n        prefix,\n        postfix,\n        thousands,\n        d = '',\n        forcedNeg = false,\n        neg = false,\n        indexOpenP,\n        indexMinus,\n        paren = '',\n        minlen,\n        i; // check if number is zero and a custom zero format has been set\n\n    if (value === 0 && zeroFormat !== null) {\n      return zeroFormat;\n    }\n\n    if (!isFinite(value)) {\n      return '' + value;\n    }\n\n    if (format.indexOf('{') === 0) {\n      var end = format.indexOf('}');\n\n      if (end === -1) {\n        throw Error('Format should also contain a \"}\"');\n      }\n\n      prefix = format.slice(1, end);\n      format = format.slice(end + 1);\n    } else {\n      prefix = '';\n    }\n\n    if (format.indexOf('}') === format.length - 1 && format.length) {\n      var start = format.indexOf('{');\n\n      if (start === -1) {\n        throw Error('Format should also contain a \"{\"');\n      }\n\n      postfix = format.slice(start + 1, -1);\n      format = format.slice(0, start + 1);\n    } else {\n      postfix = '';\n    } // check for min length\n\n\n    var info;\n\n    if (format.indexOf('.') === -1) {\n      info = format.match(/([0-9]+).*/);\n    } else {\n      info = format.match(/([0-9]+)\\..*/);\n    }\n\n    minlen = info === null ? -1 : info[1].length; // see if we should use parentheses for negative number or if we should prefix with a sign\n    // if both are present we default to parentheses\n\n    if (format.indexOf('-') !== -1) {\n      forcedNeg = true;\n    }\n\n    if (format.indexOf('(') > -1) {\n      negP = true;\n      format = format.slice(1, -1);\n    } else if (format.indexOf('+') > -1) {\n      signed = true;\n      format = format.replace(/\\+/g, '');\n    } // see if abbreviation is wanted\n\n\n    if (format.indexOf('a') > -1) {\n      intPrecision = format.split('.')[0].match(/[0-9]+/g) || ['0'];\n      intPrecision = parseInt(intPrecision[0], 10); // check if abbreviation is specified\n\n      abbrK = format.indexOf('aK') >= 0;\n      abbrM = format.indexOf('aM') >= 0;\n      abbrB = format.indexOf('aB') >= 0;\n      abbrT = format.indexOf('aT') >= 0;\n      abbrForce = abbrK || abbrM || abbrB || abbrT; // check for space before abbreviation\n\n      if (format.indexOf(' a') > -1) {\n        abbr = ' ';\n        format = format.replace(' a', '');\n      } else {\n        format = format.replace('a', '');\n      }\n\n      totalLength = numberLength(value);\n      minimumPrecision = totalLength % 3;\n      minimumPrecision = minimumPrecision === 0 ? 3 : minimumPrecision;\n\n      if (intPrecision && abs !== 0) {\n        pow = 3 * ~~((Math.min(intPrecision, totalLength) - minimumPrecision) / 3);\n        abs = abs / Math.pow(10, pow);\n      }\n\n      if (totalLength !== intPrecision) {\n        if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {\n          // trillion\n          abbr = abbr + cultures[currentCulture].abbreviations.trillion;\n          value = value / Math.pow(10, 12);\n        } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {\n          // billion\n          abbr = abbr + cultures[currentCulture].abbreviations.billion;\n          value = value / Math.pow(10, 9);\n        } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {\n          // million\n          abbr = abbr + cultures[currentCulture].abbreviations.million;\n          value = value / Math.pow(10, 6);\n        } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {\n          // thousand\n          abbr = abbr + cultures[currentCulture].abbreviations.thousand;\n          value = value / Math.pow(10, 3);\n        }\n      }\n\n      length = numberLength(value);\n\n      if (intPrecision && length < intPrecision && format.indexOf('.') === -1) {\n        format += '[.]';\n        format += zeroes(intPrecision - length);\n      }\n    } // see if we are formatting\n    //   binary-decimal bytes (1024 MB), binary bytes (1024 MiB), or decimal bytes (1000 MB)\n\n\n    for (i = 0; i < byteFormatOrder.length; ++i) {\n      byteFormat = byteFormatOrder[i];\n\n      if (format.indexOf(byteFormat.marker) > -1) {\n        // check for space before\n        if (format.indexOf(' ' + byteFormat.marker) > -1) {\n          bytes = ' ';\n        } // remove the marker (with the space if it had one)\n\n\n        format = format.replace(bytes + byteFormat.marker, '');\n        units = formatByteUnits(value, byteFormat.suffixes, byteFormat.scale);\n        value = units.value;\n        bytes = bytes + units.suffix;\n        break;\n      }\n    } // see if ordinal is wanted\n\n\n    if (format.indexOf('o') > -1) {\n      // check for space before\n      if (format.indexOf(' o') > -1) {\n        ord = ' ';\n        format = format.replace(' o', '');\n      } else {\n        format = format.replace('o', '');\n      }\n\n      if (cultures[currentCulture].ordinal) {\n        ord = ord + cultures[currentCulture].ordinal(value);\n      }\n    }\n\n    if (format.indexOf('[.]') > -1) {\n      optDec = true;\n      format = format.replace('[.]', '.');\n    }\n\n    precision = format.split('.')[1];\n    thousands = format.indexOf(',');\n\n    if (precision) {\n      var dSplit = [];\n\n      if (precision.indexOf('*') !== -1) {\n        d = value.toString();\n        dSplit = d.split('.');\n\n        if (dSplit.length > 1) {\n          d = toFixed(value, dSplit[1].length, roundingFunction);\n        }\n      } else {\n        if (precision.indexOf('[') > -1) {\n          precision = precision.replace(']', '');\n          precision = precision.split('[');\n          d = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);\n        } else {\n          d = toFixed(value, precision.length, roundingFunction);\n        }\n      }\n\n      dSplit = d.split('.');\n      w = dSplit[0];\n\n      if (dSplit.length > 1 && dSplit[1].length) {\n        var p = sep ? abbr + sep : cultures[currentCulture].delimiters.decimal;\n        d = p + dSplit[1];\n      } else {\n        d = '';\n      }\n\n      if (optDec && Number(d.slice(1)) === 0) {\n        d = '';\n      }\n    } else {\n      w = toFixed(value, 0, roundingFunction);\n    } // format number\n\n\n    if (w.indexOf('-') > -1) {\n      w = w.slice(1);\n      neg = true;\n    }\n\n    if (w.length < minlen) {\n      w = zeroes(minlen - w.length) + w;\n    }\n\n    if (thousands > -1) {\n      w = w.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + cultures[currentCulture].delimiters.thousands);\n    }\n\n    if (format.indexOf('.') === 0) {\n      w = '';\n    }\n\n    indexOpenP = format.indexOf('(');\n    indexMinus = format.indexOf('-');\n\n    if (indexOpenP < indexMinus) {\n      paren = (negP && neg ? '(' : '') + (forcedNeg && neg || !negP && neg ? '-' : '');\n    } else {\n      paren = (forcedNeg && neg || !negP && neg ? '-' : '') + (negP && neg ? '(' : '');\n    }\n\n    return prefix + paren + (!neg && signed && value !== 0 ? '+' : '') + w + d + (ord ? ord : '') + (abbr && !sep ? abbr : '') + (bytes ? bytes : '') + (negP && neg ? ')' : '') + postfix;\n  }\n  /************************************\n      Top Level Functions\n  ************************************/\n\n\n  _numbro = function numbro(input) {\n    if (_numbro.isNumbro(input)) {\n      input = input.value();\n    } else if (typeof input === 'string' || typeof input === 'number') {\n      input = _numbro.fn.unformat(input);\n    } else {\n      input = NaN;\n    }\n\n    return new Numbro(Number(input));\n  }; // version number\n\n\n  _numbro.version = VERSION; // compare numbro object\n\n  _numbro.isNumbro = function (obj) {\n    return obj instanceof Numbro;\n  };\n  /**\n   * This function allow the user to set a new language with a fallback if\n   * the language does not exist. If no fallback language is provided,\n   * it fallbacks to english.\n   *\n   * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n   * `setCulture` should be used instead.\n   */\n\n\n  _numbro.setLanguage = function (newLanguage, fallbackLanguage) {\n    console.warn('`setLanguage` is deprecated since version 1.6.0. Use `setCulture` instead');\n    var key = newLanguage,\n        prefix = newLanguage.split('-')[0],\n        matchingLanguage = null;\n\n    if (!languages[key]) {\n      Object.keys(languages).forEach(function (language) {\n        if (!matchingLanguage && language.split('-')[0] === prefix) {\n          matchingLanguage = language;\n        }\n      });\n      key = matchingLanguage || fallbackLanguage || 'en-US';\n    }\n\n    chooseCulture(key);\n  };\n  /**\n   * This function allow the user to set a new culture with a fallback if\n   * the culture does not exist. If no fallback culture is provided,\n   * it falls back to \"en-US\".\n   */\n\n\n  _numbro.setCulture = function (newCulture, fallbackCulture) {\n    var key = newCulture,\n        suffix = newCulture.split('-')[1],\n        matchingCulture = null;\n\n    if (!cultures[key]) {\n      if (suffix) {\n        Object.keys(cultures).forEach(function (language) {\n          if (!matchingCulture && language.split('-')[1] === suffix) {\n            matchingCulture = language;\n          }\n        });\n      }\n\n      key = matchingCulture || fallbackCulture || 'en-US';\n    }\n\n    chooseCulture(key);\n  };\n  /**\n   * This function will load languages and then set the global language.  If\n   * no arguments are passed in, it will simply return the current global\n   * language key.\n   *\n   * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n   * `culture` should be used instead.\n   */\n\n\n  _numbro.language = function (key, values) {\n    console.warn('`language` is deprecated since version 1.6.0. Use `culture` instead');\n\n    if (!key) {\n      return currentCulture;\n    }\n\n    if (key && !values) {\n      if (!languages[key]) {\n        throw new Error('Unknown language : ' + key);\n      }\n\n      chooseCulture(key);\n    }\n\n    if (values || !languages[key]) {\n      setCulture(key, values);\n    }\n\n    return _numbro;\n  };\n  /**\n   * This function will load cultures and then set the global culture.  If\n   * no arguments are passed in, it will simply return the current global\n   * culture code.\n   */\n\n\n  _numbro.culture = function (code, values) {\n    if (!code) {\n      return currentCulture;\n    }\n\n    if (code && !values) {\n      if (!cultures[code]) {\n        throw new Error('Unknown culture : ' + code);\n      }\n\n      chooseCulture(code);\n    }\n\n    if (values || !cultures[code]) {\n      setCulture(code, values);\n    }\n\n    return _numbro;\n  };\n  /**\n   * This function provides access to the loaded language data.  If\n   * no arguments are passed in, it will simply return the current\n   * global language object.\n   *\n   * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n   * `culture` should be used instead.\n   */\n\n\n  _numbro.languageData = function (key) {\n    console.warn('`languageData` is deprecated since version 1.6.0. Use `cultureData` instead');\n\n    if (!key) {\n      return languages[currentCulture];\n    }\n\n    if (!languages[key]) {\n      throw new Error('Unknown language : ' + key);\n    }\n\n    return languages[key];\n  };\n  /**\n   * This function provides access to the loaded culture data.  If\n   * no arguments are passed in, it will simply return the current\n   * global culture object.\n   */\n\n\n  _numbro.cultureData = function (code) {\n    if (!code) {\n      return cultures[currentCulture];\n    }\n\n    if (!cultures[code]) {\n      throw new Error('Unknown culture : ' + code);\n    }\n\n    return cultures[code];\n  };\n\n  _numbro.culture('en-US', enUS);\n  /**\n   * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n   * `cultures` should be used instead.\n   */\n\n\n  _numbro.languages = function () {\n    console.warn('`languages` is deprecated since version 1.6.0. Use `cultures` instead');\n    return languages;\n  };\n\n  _numbro.cultures = function () {\n    return cultures;\n  };\n\n  _numbro.zeroFormat = function (format) {\n    zeroFormat = typeof format === 'string' ? format : null;\n  };\n\n  _numbro.defaultFormat = function (format) {\n    defaultFormat = typeof format === 'string' ? format : '0.0';\n  };\n\n  _numbro.defaultCurrencyFormat = function (format) {\n    defaultCurrencyFormat = typeof format === 'string' ? format : '0$';\n  };\n\n  _numbro.validate = function (val, culture) {\n    var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, cultureData, temp; //coerce val to string\n\n\n    if (typeof val !== 'string') {\n      val += '';\n\n      if (console.warn) {\n        console.warn('Numbro.js: Value is not string. It has been co-erced to: ', val);\n      }\n    } //trim whitespaces from either sides\n\n\n    val = val.trim(); //replace the initial '+' or '-' sign if present\n\n    val = val.replace(/^[+-]?/, ''); //if val is just digits return true\n\n    if (!!val.match(/^\\d+$/)) {\n      return true;\n    } //if val is empty return false\n\n\n    if (val === '') {\n      return false;\n    } //get the decimal and thousands separator from numbro.cultureData\n\n\n    try {\n      //check if the culture is understood by numbro. if not, default it to current culture\n      cultureData = _numbro.cultureData(culture);\n    } catch (e) {\n      cultureData = _numbro.cultureData(_numbro.culture());\n    } //setup the delimiters and currency symbol based on culture\n\n\n    _currSymbol = cultureData.currency.symbol;\n    _abbrObj = cultureData.abbreviations;\n    _decimalSep = cultureData.delimiters.decimal;\n\n    if (cultureData.delimiters.thousands === '.') {\n      _thousandSep = '\\\\.';\n    } else {\n      _thousandSep = cultureData.delimiters.thousands;\n    } // validating currency symbol\n\n\n    temp = val.match(/^[^\\d\\.\\,]+/);\n\n    if (temp !== null) {\n      val = val.substr(1);\n\n      if (temp[0] !== _currSymbol) {\n        return false;\n      }\n    } //validating abbreviation symbol\n\n\n    temp = val.match(/[^\\d]+$/);\n\n    if (temp !== null) {\n      val = val.slice(0, -1);\n\n      if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {\n        return false;\n      }\n    }\n\n    _thousandRegEx = new RegExp(_thousandSep + '{2}');\n\n    if (!val.match(/[^\\d.,]/g)) {\n      _valArray = val.split(_decimalSep);\n\n      if (_valArray.length > 2) {\n        return false;\n      } else {\n        if (_valArray.length < 2) {\n          return !!_valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx);\n        } else {\n          if (_valArray[0] === '') {\n            // for values without leading zero eg. .984\n            return !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\\d+$/);\n          } else if (_valArray[0].length === 1) {\n            return !!_valArray[0].match(/^\\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\\d+$/);\n          } else {\n            return !!_valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\\d+$/);\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n   * `loadCulturesInNode` should be used instead.\n   */\n\n\n  _numbro.loadLanguagesInNode = function () {\n    console.warn('`loadLanguagesInNode` is deprecated since version 1.6.0. Use `loadCulturesInNode` instead');\n\n    _numbro.loadCulturesInNode();\n  };\n\n  _numbro.loadCulturesInNode = function () {\n    // TODO: Rename the folder in 2.0.0\n    var cultures = require('./languages');\n\n    for (var langLocaleCode in cultures) {\n      if (langLocaleCode) {\n        _numbro.culture(langLocaleCode, cultures[langLocaleCode]);\n      }\n    }\n  };\n  /************************************\n      Helpers\n  ************************************/\n\n\n  function setCulture(code, values) {\n    cultures[code] = values;\n  }\n\n  function chooseCulture(code) {\n    currentCulture = code;\n    var defaults = cultures[code].defaults;\n\n    if (defaults && defaults.format) {\n      _numbro.defaultFormat(defaults.format);\n    }\n\n    if (defaults && defaults.currencyFormat) {\n      _numbro.defaultCurrencyFormat(defaults.currencyFormat);\n    }\n  }\n\n  function inNodejsRuntime() {\n    return typeof process !== 'undefined' && process.browser === undefined && process.title && (process.title.indexOf('node') !== -1 || process.title.indexOf('meteor-tool') > 0 || process.title === 'grunt' || process.title === 'gulp') && typeof require !== 'undefined';\n  }\n  /************************************\n      Floating-point helpers\n  ************************************/\n  // The floating-point helper functions and implementation\n  // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/\n\n  /**\n   * Array.prototype.reduce for browsers that don't support it\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility\n   */\n\n\n  if ('function' !== typeof Array.prototype.reduce) {\n    Array.prototype.reduce = function (callback, optInitialValue) {\n      if (null === this || 'undefined' === typeof this) {\n        // At the moment all modern browsers, that support strict mode, have\n        // native implementation of Array.prototype.reduce. For instance, IE8\n        // does not support strict mode, so this check is actually useless.\n        throw new TypeError('Array.prototype.reduce called on null or undefined');\n      }\n\n      if ('function' !== typeof callback) {\n        throw new TypeError(callback + ' is not a function');\n      }\n\n      var index,\n          value,\n          length = this.length >>> 0,\n          isValueSet = false;\n\n      if (1 < arguments.length) {\n        value = optInitialValue;\n        isValueSet = true;\n      }\n\n      for (index = 0; length > index; ++index) {\n        if (this.hasOwnProperty(index)) {\n          if (isValueSet) {\n            value = callback(value, this[index], index, this);\n          } else {\n            value = this[index];\n            isValueSet = true;\n          }\n        }\n      }\n\n      if (!isValueSet) {\n        throw new TypeError('Reduce of empty array with no initial value');\n      }\n\n      return value;\n    };\n  }\n  /**\n   * Computes the multiplier necessary to make x >= 1,\n   * effectively eliminating miscalculations caused by\n   * finite precision.\n   */\n\n\n  function multiplier(x) {\n    var parts = x.toString().split('.');\n\n    if (parts.length < 2) {\n      return 1;\n    }\n\n    return Math.pow(10, parts[1].length);\n  }\n  /**\n   * Given a variable number of arguments, returns the maximum\n   * multiplier that must be used to normalize an operation involving\n   * all of them.\n   */\n\n\n  function correctionFactor() {\n    var args = Array.prototype.slice.call(arguments);\n    return args.reduce(function (prev, next) {\n      var mp = multiplier(prev),\n          mn = multiplier(next);\n      return mp > mn ? mp : mn;\n    }, -Infinity);\n  }\n  /************************************\n      Numbro Prototype\n  ************************************/\n\n\n  _numbro.fn = Numbro.prototype = {\n    clone: function clone() {\n      return _numbro(this);\n    },\n    format: function format(inputString, roundingFunction) {\n      return formatNumbro(this, inputString ? inputString : defaultFormat, roundingFunction !== undefined ? roundingFunction : Math.round);\n    },\n    formatCurrency: function formatCurrency(inputString, roundingFunction) {\n      return _formatCurrency(this, cultures[currentCulture].currency.symbol, inputString ? inputString : defaultCurrencyFormat, roundingFunction !== undefined ? roundingFunction : Math.round);\n    },\n    formatForeignCurrency: function formatForeignCurrency(currencySymbol, inputString, roundingFunction) {\n      return _formatForeignCurrency(this, currencySymbol, inputString ? inputString : defaultCurrencyFormat, roundingFunction !== undefined ? roundingFunction : Math.round);\n    },\n    unformat: function unformat(inputString) {\n      if (typeof inputString === 'number') {\n        return inputString;\n      } else if (typeof inputString === 'string') {\n        var result = unformatNumbro(this, inputString); // Any unparseable string (represented as NaN in the result) is\n        // converted into undefined.\n\n        return isNaN(result) ? undefined : result;\n      } else {\n        return undefined;\n      }\n    },\n    binaryByteUnits: function binaryByteUnits() {\n      return formatByteUnits(this._value, bytes.binary.suffixes, bytes.binary.scale).suffix;\n    },\n    byteUnits: function byteUnits() {\n      return formatByteUnits(this._value, bytes.general.suffixes, bytes.general.scale).suffix;\n    },\n    decimalByteUnits: function decimalByteUnits() {\n      return formatByteUnits(this._value, bytes.decimal.suffixes, bytes.decimal.scale).suffix;\n    },\n    value: function value() {\n      return this._value;\n    },\n    valueOf: function valueOf() {\n      return this._value;\n    },\n    set: function set(value) {\n      this._value = Number(value);\n      return this;\n    },\n    add: function add(value) {\n      var corrFactor = correctionFactor.call(null, this._value, value);\n\n      function cback(accum, curr) {\n        return accum + corrFactor * curr;\n      }\n\n      this._value = [this._value, value].reduce(cback, 0) / corrFactor;\n      return this;\n    },\n    subtract: function subtract(value) {\n      var corrFactor = correctionFactor.call(null, this._value, value);\n\n      function cback(accum, curr) {\n        return accum - corrFactor * curr;\n      }\n\n      this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;\n      return this;\n    },\n    multiply: function multiply(value) {\n      function cback(accum, curr) {\n        var corrFactor = correctionFactor(accum, curr),\n            result = accum * corrFactor;\n        result *= curr * corrFactor;\n        result /= corrFactor * corrFactor;\n        return result;\n      }\n\n      this._value = [this._value, value].reduce(cback, 1);\n      return this;\n    },\n    divide: function divide(value) {\n      function cback(accum, curr) {\n        var corrFactor = correctionFactor(accum, curr);\n        return accum * corrFactor / (curr * corrFactor);\n      }\n\n      this._value = [this._value, value].reduce(cback);\n      return this;\n    },\n    difference: function difference(value) {\n      return Math.abs(_numbro(this._value).subtract(value).value());\n    }\n  };\n  /************************************\n      Exposing Numbro\n  ************************************/\n\n  if (inNodejsRuntime()) {\n    //Todo: Rename the folder in 2.0.0\n    _numbro.loadCulturesInNode();\n  } // CommonJS module is defined\n\n\n  if (hasModule) {\n    module.exports = _numbro;\n  } else {\n    /*global ender:false */\n    if (typeof ender === 'undefined') {\n      // here, `this` means `window` in the browser, or `global` on the server\n      // add `numbro` as a global object via a string identifier,\n      // for Closure Compiler 'advanced' mode\n      this.numbro = _numbro;\n    }\n    /*global define:false */\n\n\n    if (typeof define === 'function' && define.amd) {\n      define([], function () {\n        return _numbro;\n      });\n    }\n  }\n}).call(typeof window === 'undefined' ? this : window);","map":null,"metadata":{},"sourceType":"script"}