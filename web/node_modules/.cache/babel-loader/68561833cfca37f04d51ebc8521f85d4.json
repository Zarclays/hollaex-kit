{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _class, _temp2;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport getLineHeight from 'line-height';\nimport ResizeObserver from 'resize-observer-polyfill';\nvar SPLIT = {\n  LEFT: true,\n  RIGHT: false\n};\n\nvar toString = function toString(node) {\n  var string = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  if (!node) {\n    return string;\n  } else if (typeof node === 'string') {\n    return string + node;\n  } else if (Array.isArray(node)) {\n    var newString = string;\n    node.forEach(function (child) {\n      newString = toString(child, newString);\n    });\n    return newString;\n  }\n\n  return toString(node.props.children, string);\n};\n\nvar cloneWithChildren = function cloneWithChildren(node, children, isRootEl, level) {\n  return _extends({}, node, {\n    props: _extends({}, node.props, {\n      style: _extends({}, node.props.style, isRootEl ? {\n        // root element cannot be an inline element because of the line calculation\n        display: (node.props.style || {}).display || 'block'\n      } : level === 2 ? {\n        // level 2 elements (direct children of the root element) need to be inline because of the ellipsis.\n        // if level 2 element was a block element, ellipsis would get rendered on a new line, breaking the max number of lines\n        display: (node.props.style || {}).display || 'inline-block'\n      } : {}),\n      children: children\n    })\n  });\n};\n\nvar validateTree = function validateTree(node) {\n  if (typeof node === 'string') {\n    return true;\n  } else if (typeof node.type === 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      /* eslint-disable no-console */\n      console.error('ReactTruncateMarkup tried to render <' + node.type.name + ' />, but truncating React components is not supported, the full content is rendered instead. Only DOM elements are supported.');\n      /* eslint-enable */\n    }\n\n    return false;\n  }\n\n  if (node.props.children) {\n    if (Array.isArray(node.props.children)) {\n      return node.props.children.reduce(function (isValid, child) {\n        return isValid && validateTree(child);\n      }, true);\n    }\n\n    return validateTree(node.props.children);\n  }\n\n  return true;\n};\n\nvar TruncateMarkup = (_temp2 = _class = function (_React$Component) {\n  _inherits(TruncateMarkup, _React$Component);\n\n  function TruncateMarkup() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, TruncateMarkup);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n      text: _this.childrenElementWithRef(_this.props.children)\n    }, _this.isValid = validateTree(_this.props.children), _this.lineHeight = null, _this.splitDirectionSeq = [], _this.shouldTruncate = true, _this.wasLastCharTested = false, _this.endFound = false, _this.latestThatFits = null, _this.origText = null, _this.clientWidth = null, _this.onAfterTruncateCalled = false, _this.onAfterTruncate = function (wasTruncated) {\n      if (!_this.onAfterTruncateCalled) {\n        _this.onAfterTruncateCalled = true;\n\n        _this.props.onAfterTruncate(wasTruncated);\n      }\n    }, _this.handleResize = function () {\n      /* Wrapper element resize handing */\n      var initialRender = true;\n      _this.resizeObserver = new ResizeObserver(function () {\n        if (initialRender) {\n          // ResizeObserer cb is called on initial render too so we are skipping here\n          initialRender = false;\n        } else {\n          // wrapper element has been resized, recalculating with the original text\n          _this.shouldTruncate = false;\n          _this.latestThatFits = null;\n\n          _this.setState({\n            text: _this.origText\n          }, function () {\n            _this.shouldTruncate = true;\n            _this.onAfterTruncateCalled = false;\n\n            _this.truncate();\n          });\n        }\n      });\n\n      _this.resizeObserver.observe(_this.el);\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  TruncateMarkup.prototype.componentDidMount = function componentDidMount() {\n    if (!this.isValid) {\n      return;\n    }\n\n    this.origText = this.state.text; // get the computed line-height of the parent element\n    // it'll be used for determining whether the text fits the container or not\n\n    this.lineHeight = this.props.lineHeight || getLineHeight(this.el);\n    this.truncate();\n    this.handleResize();\n  };\n\n  TruncateMarkup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _this2 = this;\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    this.shouldTruncate = false;\n    this.latestThatFits = null;\n    this.isValid = validateTree(nextProps.children);\n    this.setState({\n      text: this.childrenElementWithRef(nextProps.children)\n    }, function () {\n      if (!_this2.isValid) {\n        return;\n      }\n\n      _this2.origText = _this2.state.text;\n      _this2.lineHeight = nextProps.lineHeight || getLineHeight(_this2.el);\n      _this2.shouldTruncate = true;\n\n      _this2.truncate();\n\n      _this2.handleResize();\n    });\n  };\n\n  TruncateMarkup.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this.shouldTruncate === false || this.isValid === false) {\n      return;\n    }\n\n    if (this.endFound) {\n      // we've found the end where we cannot split the text further\n      // that means we've already found the max subtree that fits the container\n      // so we are rendering that\n      if (this.state.text !== this.latestThatFits) {\n        /* eslint-disable react/no-did-update-set-state */\n        this.setState({\n          text: this.latestThatFits\n        });\n        return;\n        /* eslint-enable */\n      } else if (this.el && this.el.clientWidth !== this.clientWidth) {\n        // edge case - scrollbar (dis?)appearing might mess up the container width\n        // causing strings that would normally fit on X lines to suddenly take up X+1 lines\n        // ugly fix - recalculate again\n        this.truncateOriginalText();\n        return;\n      }\n\n      this.onAfterTruncate(\n      /* wasTruncated */\n      true);\n      return;\n    }\n\n    if (this.splitDirectionSeq.length) {\n      if (this.fits()) {\n        this.latestThatFits = this.state.text;\n        this.clientWidth = this.el.clientWidth; // we've found a subtree that fits the container\n        // but we need to check if we didn't cut too much of it off\n        // so we are changing the last splitting decision from splitting and going left\n        // to splitting and going right\n\n        this.splitDirectionSeq.splice(this.splitDirectionSeq.length - 1, 1, SPLIT.RIGHT, SPLIT.LEFT);\n      } else {\n        this.splitDirectionSeq.push(SPLIT.LEFT);\n      }\n\n      this.tryToFit(this.origText, this.splitDirectionSeq);\n    }\n  };\n\n  TruncateMarkup.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    this.lineHeight = null;\n    this.origText = null;\n    this.latestThatFits = null;\n    this.splitDirectionSeq = [];\n  };\n\n  TruncateMarkup.prototype.truncate = function truncate() {\n    if (this.fits()) {\n      // the whole text fits on the first try, no need to do anything else\n      this.shouldTruncate = false;\n      this.onAfterTruncate(\n      /* wasTruncated */\n      false);\n      return;\n    }\n\n    this.truncateOriginalText();\n  };\n\n  TruncateMarkup.prototype.childrenElementWithRef = function childrenElementWithRef(children) {\n    var _this3 = this;\n\n    var child = React.Children.only(children);\n    return React.cloneElement(child, {\n      ref: function ref(el) {\n        return _this3.el = el;\n      }\n    });\n  };\n\n  TruncateMarkup.prototype.truncateOriginalText = function truncateOriginalText() {\n    this.endFound = false;\n    this.splitDirectionSeq = [SPLIT.LEFT];\n    this.wasLastCharTested = false;\n    this.tryToFit(this.origText, this.splitDirectionSeq);\n  };\n  /**\n   * Splits rootEl based on instructions and updates React's state with the returned element\n   * After React rerenders the new text, we'll check if the new text fits in componentDidUpdate\n   * @param  {ReactElement} rootEl - the original children element\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   */\n\n\n  TruncateMarkup.prototype.tryToFit = function tryToFit(rootEl, splitDirections) {\n    if (!rootEl.props.children) {\n      // no markup in container\n      return;\n    }\n\n    var newRootEl = this.split(rootEl, splitDirections,\n    /* isRootEl */\n    true);\n    var ellipsis = typeof this.props.ellipsis === 'function' ? this.props.ellipsis(newRootEl) : this.props.ellipsis;\n    ellipsis = (typeof ellipsis === 'undefined' ? 'undefined' : _typeof(ellipsis)) === 'object' ? React.cloneElement(ellipsis, {\n      key: 'ellipsis'\n    }) : ellipsis;\n    var newChildren = newRootEl.props.children;\n    var newChildrenWithEllipsis = Array.isArray(newChildren) ? [].concat(newChildren, [ellipsis]) : [newChildren, ellipsis]; // edge case tradeoff EC#1 - on initial render it doesn't fit in the requested number of lines (1) so it starts truncating\n    // - because of truncating and the ellipsis position, div#lvl2 will have display set to 'inline-block',\n    //   causing the whole body to fit in 1 line again\n    // - if that happens, ellipsis is not needed anymore as the whole body is rendered\n    // - NOTE this could be fixed by checking for this exact case and handling it separately so it renders <div>foo {ellipsis}</div>\n    //\n    // Example:\n    // <TruncateMarkup lines={1}>\n    //   <div>\n    //     foo\n    //     <div id=\"lvl2\">bar</div>\n    //   </div>\n    // </TruncateMarkup>\n\n    var shouldRenderEllipsis = toString(newChildren) !== toString(this.origText);\n    this.setState({\n      text: _extends({}, newRootEl, {\n        props: _extends({}, newRootEl.props, {\n          style: _extends({\n            wordWrap: 'break-word'\n          }, newRootEl.props.style),\n          children: shouldRenderEllipsis ? newChildrenWithEllipsis : newChildren\n        })\n      })\n    });\n  };\n  /**\n   * Splits JSX node based on its type\n   * @param  {null|string|Array|Object} node - JSX node\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   * @return {null|string|Array|Object} - split JSX node\n   */\n\n\n  TruncateMarkup.prototype.split = function split(node, splitDirections) {\n    var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    if (!node) {\n      return node;\n    } else if (typeof node === 'string') {\n      return this.splitString(node, splitDirections);\n    } else if (Array.isArray(node)) {\n      return this.splitArray(node, splitDirections, level);\n    }\n\n    var newChildren = this.split(node.props.children, splitDirections,\n    /* isRoot */\n    false, level + 1);\n    return cloneWithChildren(node, newChildren, isRoot, level);\n  };\n\n  TruncateMarkup.prototype.splitString = function splitString(string) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (!splitDirections.length) {\n      return string;\n    }\n\n    if (splitDirections.length && string.length === 1) {\n      // allow for an extra render test with the current character included\n      // in most cases this variation was already tested, but some edge cases require this check\n      // NOTE could be removed once EC#1 is taken care of\n      if (!this.wasLastCharTested) {\n        this.wasLastCharTested = true;\n      } else {\n        // we are trying to split further but we have nowhere to go now\n        // that means we've already found the max subtree that fits the container\n        this.endFound = true;\n      }\n\n      return string;\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n    var pivotIndex = Math.ceil(string.length / 2);\n\n    if (splitDirection === SPLIT.LEFT) {\n      var subString = string.substring(0, pivotIndex);\n      return this.splitString(subString, restSplitDirections);\n    }\n\n    var beforeString = string.substring(0, pivotIndex);\n    var afterString = string.substring(pivotIndex);\n    return beforeString + this.splitString(afterString, restSplitDirections);\n  };\n\n  TruncateMarkup.prototype.splitArray = function splitArray(array) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var level = arguments[2];\n\n    if (!splitDirections.length) {\n      return array;\n    }\n\n    if (array.length === 1) {\n      var item = array[0];\n\n      if (typeof item === 'string') {\n        return [this.splitString(item, splitDirections)];\n      }\n\n      var children = item.props.children;\n      var newChildren = this.split(children, splitDirections,\n      /* isRoot */\n      false, level + 1);\n      return [cloneWithChildren(item, newChildren,\n      /* isRoot */\n      false, level)];\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n    var pivotIndex = Math.ceil(array.length / 2);\n\n    if (splitDirection === SPLIT.LEFT) {\n      var subArray = array.slice(0, pivotIndex);\n      return this.splitArray(subArray, restSplitDirections, level);\n    }\n\n    var beforeArray = array.slice(0, pivotIndex);\n    var afterArray = array.slice(pivotIndex);\n    return beforeArray.concat(this.splitArray(afterArray, restSplitDirections, level));\n  };\n\n  TruncateMarkup.prototype.fits = function fits() {\n    var maxLines = this.props.lines;\n\n    var _el$getBoundingClient = this.el.getBoundingClientRect(),\n        height = _el$getBoundingClient.height;\n\n    var computedLines = Math.round(height / parseFloat(this.lineHeight));\n\n    if (process.env.NODE_ENV !== 'production' && computedLines <= 0) {\n      /* eslint-disable no-console */\n      console.warn('ReactTruncateMarkup: number of currently rendered lines: ' + computedLines + ', not truncating...\\n  It may be caused by target element not being visible at the time of computation.');\n      /* eslint-enable */\n    }\n\n    return maxLines >= computedLines;\n  };\n\n  TruncateMarkup.prototype.render = function render() {\n    return this.state.text;\n  };\n\n  return TruncateMarkup;\n}(React.Component), _class.defaultProps = {\n  lines: 1,\n  ellipsis: '...',\n  lineHeight: '',\n  onAfterTruncate: function onAfterTruncate() {}\n}, _temp2);\nexport { TruncateMarkup as default };\nTruncateMarkup.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  children: PropTypes.element.isRequired,\n  lines: PropTypes.number,\n  ellipsis: PropTypes.oneOfType([PropTypes.element, PropTypes.string, PropTypes.func]),\n  lineHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  onAfterTruncate: PropTypes.func\n} : {};","map":null,"metadata":{},"sourceType":"module"}